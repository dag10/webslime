<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
        <title>PCB Surface Test</title>
        <style>
            *,
            html,
            body {
                margin: 0;
                padding: 0;
            }
            html,
            body {
                width: 100%;
                height: 100%;
                background: #000;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            #c {
                display: block;
                width: 720px;
                height: 960px;
                touch-action: none;
                max-width: 100vw;
                max-height: 100vh;
                object-fit: contain;
            }
            #fps {
                position: fixed;
                top: 8px;
                left: 8px;
                color: rgba(255, 255, 255, 0.6);
                font: 12px monospace;
                pointer-events: none;
                z-index: 10;
            }
            #loading {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000;
                z-index: 100;
                transition: opacity 0.4s ease-out;
            }
        </style>
    </head>
    <body>
        <div id="fps"></div>
        <div id="loading"></div>
        <canvas id="c"></canvas>

        <script>
            var fluidRim = 1.2,
                fluidRimPow = 10,
                camPitch = 0,
                nrmStr = 45,
                fluidAmbient = 0,
                fluidRough = 0.06,
                fluidF0 = 0.01,
                edgeCut = 0.025,
                blurInner = 0.25,
                blurOuter = 1.5,
                blurAmt = 30,
                coneHeight = 0.4,
                coneRad = 0.025,
                coneFalloff = 1,
                trailHeight = 0.2,
                tipShape = 2,
                seedStr = 0.006,
                seedThr = 0.2,
                seedSpd = 6,
                seedScale = 30,
                splatK = 6,
                rdAdvect = 0.02,
                advDecay = 0.75,
                W = 720,
                H = 960,
                canvas = document.getElementById('c');
            ((canvas.width = W), (canvas.height = H));
            var gl = canvas.getContext('webgl2', { preserveDrawingBuffer: !0 });
            (gl.getExtension('EXT_color_buffer_float'),
                gl.getExtension('OES_texture_float_linear'));
            var quadVerts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
                quadBuf = gl.createBuffer();
            (gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf),
                gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW));
            var quadVAO = gl.createVertexArray();
            function compileShader(e, n) {
                var o = gl.createShader(e);
                return (
                    gl.shaderSource(o, n),
                    gl.compileShader(o),
                    gl.getShaderParameter(o, gl.COMPILE_STATUS) ||
                        console.error('Shader error:', gl.getShaderInfoLog(o)),
                    o
                );
            }
            function linkProg(e, n) {
                var o = gl.createProgram();
                return (
                    gl.attachShader(o, compileShader(gl.VERTEX_SHADER, e)),
                    gl.attachShader(o, compileShader(gl.FRAGMENT_SHADER, n)),
                    gl.linkProgram(o),
                    gl.getProgramParameter(o, gl.LINK_STATUS) ||
                        console.error('Link error:', gl.getProgramInfoLog(o)),
                    o
                );
            }
            (gl.bindVertexArray(quadVAO),
                gl.enableVertexAttribArray(0),
                gl.vertexAttribPointer(0, 2, gl.FLOAT, !1, 0, 0));
            var vertSrc =
                    '#version 300 es\n    layout(location=0) in vec2 pos;\n    out vec2 vUV;\n    void main() {\n        vUV = pos * 0.5 + 0.5;\n        gl_Position = vec4(pos, 0, 1);\n    }',
                tRng = 7;
            function trand() {
                return (65535 & (tRng = (1103515245 * tRng + 12345) & 2147483647)) / 65535;
            }
            for (var coneSeeds = [], ci = 0; ci < 15; ci++) {
                var cAngle = trand() * Math.PI * 2,
                    cDist = trand() * trand(),
                    cSize = 0.6 + 0.8 * trand();
                coneSeeds.push({
                    angle: cAngle,
                    dist: cDist,
                    size: cSize,
                    px: 0.5,
                    py: 0.5,
                    vx: 0,
                    vy: 0,
                    tipX: 0.5,
                    tipY: 0.5,
                    splatX: 0.5,
                    splatY: 0.5,
                    squash: 0,
                    squashNX: 0,
                    squashNY: 0,
                });
            }
            var wanderEnabled = !0;
            function screenToWorldX(e) {
                return getVisScale() * e + scrollX;
            }
            function screenToWorldY(e) {
                return getVisScale() * e + scrollY;
            }
            function worldToScreenX(e) {
                return (e - scrollX) / getVisScale();
            }
            function worldToScreenY(e) {
                return (e - scrollY) / getVisScale();
            }
            var F = Math.fround;
            function f32arg(e, n, o, t, a) {
                return F(F(F(e * F(n)) + F(o * F(t))) + F(a));
            }
            function jsFract(e) {
                return ((e = F(e)), F(e - Math.floor(e)));
            }
            function jsHash21(e, n) {
                ((e = jsFract(F(F(e) * F(123.34)))), (n = jsFract(F(F(n) * F(456.21)))));
                var o = F(F(e * F(e + F(45.32))) + F(n * F(n + F(45.32))));
                return ((e = F(e + o)), (n = F(n + o)), jsFract(F(e * n)));
            }
            function jsHash22(e, n) {
                return [jsHash21(e, n), jsHash21(F(F(e) + F(37.158)), F(F(n) + F(91.237)))];
            }
            function jsVnoise(e, n) {
                ((e = F(e)), (n = F(n)));
                var o = Math.floor(e),
                    t = Math.floor(n),
                    a = F(e - o),
                    r = F(n - t);
                ((a = F(F(a * a) * F(3 - F(2 * a)))), (r = F(F(r * r) * F(3 - F(2 * r)))));
                var l = jsHash21(o, t),
                    i = jsHash21(o + 1, t),
                    c = jsHash21(o, t + 1),
                    s = jsHash21(o + 1, t + 1),
                    f = F(F(l * F(1 - a)) + F(i * a)),
                    d = F(F(c * F(1 - a)) + F(s * a));
                return F(F(f * F(1 - r)) + F(d * r));
            }
            function jsIsWall(e, n, o) {
                var t = 0.25,
                    a = Math.floor(F(F(n) / F(t))),
                    r = F(F(a + F(0.5)) * F(t)),
                    l = F(
                        F(jsVnoise(F(F(e) * F(4)), f32arg(a, 7.13, o, 3.1, 0)) - F(0.5)) * F(0.03),
                    );
                if (Math.abs(F(F(n) - F(r) - l)) < 0.03) return !1;
                var i = Math.floor(F(F(e) / F(t))),
                    c = F(F(i + F(0.5)) * F(t)),
                    s = F(
                        F(jsVnoise(f32arg(i, 9.37, o, 5.7, 0), F(F(n) * F(4))) - F(0.5)) * F(0.03),
                    );
                return !(Math.abs(F(F(e) - F(c) - s)) < 0.03);
            }
            function circleVsRect(e, n, o, t, a, r, l) {
                var i = e - Math.max(t - r, Math.min(e, t + r)),
                    c = n - Math.max(a - l, Math.min(n, a + l)),
                    s = i * i + c * c;
                if (s >= o * o) return null;
                var f = Math.sqrt(s);
                if (f < 1e-5) {
                    var d = r - Math.abs(e - t),
                        u = l - Math.abs(n - a);
                    return d < u
                        ? { nx: e < t ? -1 : 1, ny: 0, pen: d + o }
                        : { nx: 0, ny: n < a ? -1 : 1, pen: u + o };
                }
                return { nx: i / f, ny: c / f, pen: o - f };
            }
            function circleVsCircle(e, n, o, t, a, r) {
                var l = e - t,
                    i = n - a,
                    c = Math.sqrt(l * l + i * i),
                    s = o + r;
                return c >= s
                    ? null
                    : c < 1e-5
                      ? { nx: 1, ny: 0, pen: s }
                      : { nx: l / c, ny: i / c, pen: s - c };
            }
            function circleVsRotRect(e, n, o, t, a, r, l, i, c) {
                var s = e - t,
                    f = n - a,
                    d = circleVsRect(i * s + c * f, -c * s + i * f, o, 0, 0, r, l);
                if (d) {
                    var u = i * d.nx - c * d.ny,
                        g = c * d.nx + i * d.ny;
                    ((d.nx = u), (d.ny = g));
                }
                return d;
            }
            var colliders = [],
                scrollBlocked = { left: 0, right: 0, up: 0, down: 0 },
                aspYX = H / W;
            function buildCellData() {
                colliders.length = 0;
                var e = 2 * -scrollX,
                    n = 2 * -scrollY,
                    o = scrollX - 0.075,
                    t = scrollX + 1.075,
                    a = scrollY - 0.075,
                    r = scrollY + 1.075,
                    l = scrollX - 0.075,
                    i = scrollX + 0.575,
                    c = scrollY - 0.075,
                    s = scrollY + 0.575,
                    f = 0.08,
                    d = F(Math.max(0.6, 0.01)),
                    u = Math.floor(o / f) - 1,
                    g = Math.floor(t / f) + 1,
                    p = Math.floor(a / f) - 1,
                    h = Math.floor(r / f) + 1;
                chipDataBuf.fill(0);
                for (var m = p; m <= h; m++)
                    for (var v = u; v <= g; v++) {
                        var T = m - p;
                        if (!(2 * (N = v - u) + 1 >= CHIP_DATA_W || T >= CHIP_DATA_H)) {
                            var x = 4 * (T * CHIP_DATA_W + 2 * N);
                            if (
                                !(
                                    jsHash21(
                                        f32arg(v, 1, 0, 13.7, 500),
                                        f32arg(m, 1, 0, 13.7, 500),
                                    ) > 0.7
                                )
                            ) {
                                var b = jsHash22(
                                        f32arg(v, 1, 0, 9.3, 700),
                                        f32arg(m, 1, 0, 9.3, 700),
                                    ),
                                    D = F(F(F(v + F(b[0] * F(0.5))) + F(0.25)) * F(f)),
                                    w = F(F(F(m + F(b[1] * F(0.5))) + F(0.25)) * F(f));
                                if (jsIsWall(D, w, 0)) {
                                    var R,
                                        E,
                                        S,
                                        U,
                                        y,
                                        A = jsHash21(
                                            f32arg(v, 5.1, 0, 6.2, 800),
                                            f32arg(m, 5.1, 0, 6.2, 800),
                                        ),
                                        L =
                                            jsHash21(
                                                f32arg(v, 6.3, 0, 3.7, 900),
                                                f32arg(m, 6.3, 0, 3.7, 900),
                                            ) < 0.35
                                                ? 7
                                                : 6,
                                        P = jsHash21(
                                            f32arg(v, 4.3, 0, 7.1, 600),
                                            f32arg(m, 4.3, 0, 7.1, 600),
                                        ),
                                        C = F(F(0.5) + F(d * F(P - F(0.5))));
                                    C < 0.2
                                        ? ((R =
                                              0.003 +
                                              0.004 *
                                                  (S = jsHash22(
                                                      f32arg(v, 2.1, 0, 1, 610),
                                                      f32arg(m, 2.1, 0, 1, 610),
                                                  ))[0]),
                                          (E = 0.005 + 0.003 * S[1]),
                                          (U = 0.002),
                                          (y = 0))
                                        : C < 0.5
                                          ? ((R =
                                                0.007 +
                                                0.007 *
                                                    (S = jsHash22(
                                                        f32arg(v, 2.5, 0, 1.3, 620),
                                                        f32arg(m, 2.5, 0, 1.3, 620),
                                                    ))[0]),
                                            (E = 0.01 + 0.005 * S[1]),
                                            (U = 0.003),
                                            (y = 1))
                                          : C < 0.78
                                            ? ((R =
                                                  0.012 +
                                                  0.01 *
                                                      (S = jsHash22(
                                                          f32arg(v, 3.1, 0, 1.7, 630),
                                                          f32arg(m, 3.1, 0, 1.7, 630),
                                                      ))[0]),
                                              (E = 0.018 + 0.008 * S[1]),
                                              (U = 0.003),
                                              (y = 2))
                                            : ((R =
                                                  0.018 +
                                                  0.018 *
                                                      (S = jsHash22(
                                                          f32arg(v, 3.5, 0, 2.1, 640),
                                                          f32arg(m, 3.5, 0, 2.1, 640),
                                                      ))[0]),
                                              (E = 0.025 + 0.015 * S[1]),
                                              (U = 0.004),
                                              (y = 3));
                                    var k = 0;
                                    if (L > 5.5 && L < 6.5 && A < 0.04) {
                                        k = 1;
                                        var _ = Math.max(R, E);
                                        ((R = _), (E = _));
                                    } else if (A >= 0.5) {
                                        var M = R;
                                        ((R = E), (E = M));
                                    }
                                    ((chipDataBuf[x + 0] = D),
                                        (chipDataBuf[x + 1] = w),
                                        (chipDataBuf[x + 2] = R),
                                        (chipDataBuf[x + 3] = E),
                                        (chipDataBuf[x + 4] = L),
                                        (chipDataBuf[x + 5] = k),
                                        (chipDataBuf[x + 6] = y),
                                        (chipDataBuf[x + 7] = 1),
                                        D >= l &&
                                            D <= i &&
                                            w >= c &&
                                            w <= s &&
                                            colliders.push({
                                                type: 1 === k ? 1 : 0,
                                                cx: 2 * D + e,
                                                cy: 2 * w + n,
                                                hx: 2 * (R + U),
                                                hy: 2 * (E + U),
                                            }));
                                }
                            }
                        }
                    }
                var X = 0.22,
                    V = Math.floor(o / X) - 1,
                    I = Math.floor(t / X) + 1,
                    G = Math.floor(a / X) - 1,
                    B = Math.floor(r / X) + 1;
                for (coarseDataBuf.fill(0), m = G; m <= B; m++)
                    for (v = V; v <= I; v++) {
                        var N;
                        if (((T = m - G), !((N = v - V) >= COARSE_DATA_W || T >= COARSE_DATA_H))) {
                            var O = 4 * (T * COARSE_DATA_W + N);
                            if (
                                !(
                                    jsHash21(
                                        f32arg(v, 1, 0, 11.37, 200),
                                        f32arg(m, 1, 0, 11.37, 200),
                                    ) > 0.4
                                )
                            ) {
                                var Y = jsHash21(
                                        f32arg(v, 2.1, 0, 4.56, 300),
                                        f32arg(m, 2.1, 0, 4.56, 300),
                                    ),
                                    z =
                                        ((b = jsHash22(
                                            f32arg(v, 1, 0, 8.91, 400),
                                            f32arg(m, 1, 0, 8.91, 400),
                                        )),
                                        F(F(F(v + F(b[0] * F(0.5))) + F(0.25)) * F(X))),
                                    q = F(F(F(m + F(b[1] * F(0.5))) + F(0.25)) * F(X)),
                                    j = 0,
                                    K = 0;
                                if (
                                    (Y < 0.3
                                        ? ((j = 4),
                                          (K =
                                              0.04 +
                                              0.035 *
                                                  jsHash21(
                                                      f32arg(v, 1.5, 0, 1, 0),
                                                      f32arg(m, 1.5, 0, 1, 0),
                                                  )))
                                        : Y < 0.55 &&
                                          ((j = 5),
                                          (K =
                                              0.012 +
                                              0.01 *
                                                  jsHash21(
                                                      f32arg(v, 1.8, 0, 2.7, 0),
                                                      f32arg(m, 1.8, 0, 2.7, 0),
                                                  ))),
                                    j < 0.5 &&
                                        jsHash21(
                                            f32arg(v, 8.7, 0, 12.3, 1100),
                                            f32arg(m, 8.7, 0, 12.3, 1100),
                                        ) < 0.18 &&
                                        !jsIsWall(z, q, 0))
                                ) {
                                    for (
                                        var $ =
                                                0.055 +
                                                0.045 *
                                                    jsHash21(
                                                        f32arg(v, 9.2, 0, 5.4, 1200),
                                                        f32arg(m, 9.2, 0, 5.4, 1200),
                                                    ),
                                            J = !0,
                                            Q = $,
                                            Z = Math.floor((z - Q) / f) - 1,
                                            ee = Math.floor((z + Q) / f) + 1,
                                            ne = Math.floor((q - Q) / f) - 1,
                                            oe = Math.floor((q + Q) / f) + 1,
                                            te = ne;
                                        te <= oe && J;
                                        te++
                                    )
                                        for (var ae = Z; ae <= ee && J; ae++) {
                                            var re = ae - u,
                                                le = te - p;
                                            if (
                                                !(
                                                    2 * re + 1 >= CHIP_DATA_W ||
                                                    le >= CHIP_DATA_H ||
                                                    re < 0 ||
                                                    le < 0
                                                )
                                            ) {
                                                var ie = 4 * (le * CHIP_DATA_W + 2 * re);
                                                if (!(chipDataBuf[ie + 7] < 0.5)) {
                                                    var ce = z - chipDataBuf[ie + 0],
                                                        se = q - chipDataBuf[ie + 1];
                                                    Math.sqrt(ce * ce + se * se) < Q && (J = !1);
                                                }
                                            }
                                        }
                                    J && ((j = 4.1), (K = $));
                                }
                                j > 0 &&
                                    ((coarseDataBuf[O + 0] = z),
                                    (coarseDataBuf[O + 1] = q),
                                    (coarseDataBuf[O + 2] = K),
                                    (coarseDataBuf[O + 3] = j),
                                    z >= l &&
                                        z <= i &&
                                        q >= c &&
                                        q <= s &&
                                        colliders.push({
                                            type: 2,
                                            cx: 2 * z + e,
                                            cy: 2 * q + n,
                                            rx: 2 * K,
                                            ry: (2 * K * W) / H,
                                        }));
                            }
                        }
                    }
                ((cellGridInfo.chipMinGX = u),
                    (cellGridInfo.chipMinGY = p),
                    (cellGridInfo.coarseMinGX = V),
                    (cellGridInfo.coarseMinGY = G),
                    gl.bindTexture(gl.TEXTURE_2D, chipDataTex),
                    gl.texSubImage2D(
                        gl.TEXTURE_2D,
                        0,
                        0,
                        0,
                        CHIP_DATA_W,
                        CHIP_DATA_H,
                        gl.RGBA,
                        gl.FLOAT,
                        chipDataBuf,
                    ),
                    gl.bindTexture(gl.TEXTURE_2D, coarseDataTex),
                    gl.texSubImage2D(
                        gl.TEXTURE_2D,
                        0,
                        0,
                        0,
                        COARSE_DATA_W,
                        COARSE_DATA_H,
                        gl.RGBA,
                        gl.FLOAT,
                        coarseDataBuf,
                    ));
            }
            var chladniModeIdx = 0,
                chladniModeTime = 0,
                CHLADNI_HOLD = 10,
                scrollX = 0.3,
                scrollY = 0.525,
                smoothComX = scrollX + 0.25,
                smoothComY = scrollY + 0.25,
                chladniTargets = [],
                chladniTargetFrom = [],
                chladniTargetTo = [],
                chladniTargetT = 1,
                CHLADNI_TARGET_DUR = 4,
                chladniNeedsAssign = !1,
                chladniRng = 42;
            function chladniRand() {
                return (
                    (65535 & (chladniRng = (1103515245 * chladniRng + 12345) & 2147483647)) / 65535
                );
            }
            var chladniPatterns = [
                [3, 0.55, 1, 0, 0],
                [4, 0.5, 0, 0, Math.PI / 4],
                [5, 0.55, 1, 0, 0],
                [3, 0.6, 3, 0.25, Math.PI / 6],
                [6, 0.5, 1, 0, 0],
                [4, 0.55, 3, 0.22, Math.PI / 4],
                [5, 0.48, 2, 0.2, Math.PI / 5],
                [7, 0.52, 0, 0, 0],
                [3, 0.45, 4, 0.2, Math.PI / 3],
            ];
            function generatePattern(e, n, o, t) {
                for (
                    var a = chladniPatterns[e % chladniPatterns.length],
                        r = 0.0525,
                        l = [],
                        i = a[0],
                        c = a[1] * r,
                        s = a[2],
                        f = a[3] * r,
                        d = a[4],
                        u = 0;
                    u < i;
                    u++
                ) {
                    var g = d + (2 * Math.PI * u) / i;
                    l.push({ ux: o + c * Math.cos(g), uy: t + c * Math.sin(g) });
                }
                if (1 === s && 0 === f) l.push({ ux: o, uy: t });
                else if (s > 0) {
                    var p = d + Math.PI / i;
                    for (u = 0; u < s; u++)
                        ((g = p + (2 * Math.PI * u) / s),
                            l.push({ ux: o + f * Math.cos(g), uy: t + f * Math.sin(g) }));
                }
                for (; l.length < n; )
                    ((g = 2 * Math.PI * chladniRand()),
                        l.push({ ux: o + 0.021 * Math.cos(g), uy: t + 0.021 * Math.sin(g) }));
                for (var h = 0; h < 100; h++)
                    for (u = 0; u < l.length; u++)
                        for (var m = u + 1; m < l.length; m++) {
                            var v = l[u].ux - l[m].ux,
                                T = l[u].uy - l[m].uy,
                                x = Math.sqrt(v * v + T * T);
                            if (x < 0.04 && x > 0.001) {
                                var b = (0.5 * (0.04 - x)) / x;
                                ((l[u].ux += v * b),
                                    (l[u].uy += T * b),
                                    (l[m].ux -= v * b),
                                    (l[m].uy -= T * b));
                            }
                        }
                return l;
            }
            function farthestAssign(e, n) {
                for (var o = [], t = {}, a = 0; a < n; a++) {
                    for (var r = coneSeeds[a], l = -1, i = -1, c = 0; c < e.length; c++)
                        if (!t[c]) {
                            var s = r.px - e[c].ux,
                                f = r.py - e[c].uy,
                                d = s * s + f * f;
                            d > l && ((l = d), (i = c));
                        }
                    i >= 0
                        ? ((t[i] = !0), (o[a] = { ux: e[i].ux, uy: e[i].uy }))
                        : (o[a] = { ux: scrollX + 0.25, uy: scrollY + 0.25 });
                }
                return o;
            }
            function shiftAllTargets(e, n) {
                // Shift all targets by the same base offset
                for (var o = 0; o < chladniTargets.length; o++)
                    (chladniTargets[o] &&
                        ((chladniTargets[o].ux += e), (chladniTargets[o].uy += n)),
                        chladniTargetFrom[o] &&
                            ((chladniTargetFrom[o].ux += e), (chladniTargetFrom[o].uy += n)),
                        chladniTargetTo[o] &&
                            ((chladniTargetTo[o].ux += e), (chladniTargetTo[o].uy += n)));

                // Velocity-dependent spreading: push targets apart when moving fast
                var speed = Math.sqrt(e * e + n * n);
                if (speed > 0.0001 && chladniTargets.length > 1) {
                    // Movement direction and perpendicular
                    var dirX = e / speed, dirY = n / speed;
                    var perpX = -dirY, perpY = dirX;
                    // Spread strength scales with speed, capped
                    var spreadStr = Math.min(speed * 1.5, 0.12);
                    var count = Math.min(Math.round(5), chladniTargets.length);
                    for (var i = 0; i < count; i++) {
                        if (!chladniTargets[i]) continue;
                        // Spread along perpendicular: evenly distribute from -1 to +1
                        var t = count > 1 ? (i / (count - 1)) * 2 - 1 : 0;
                        // Also stagger along movement direction (leader/trailer)
                        var along = ((i % 2 === 0) ? 1 : -1) * 0.6;
                        chladniTargets[i].ux += perpX * t * spreadStr + dirX * along * spreadStr * 0.5;
                        chladniTargets[i].uy += perpY * t * spreadStr + dirY * along * spreadStr * 0.5;
                    }
                }
            }
            function updateConeWander(e, n) {
                if (!wanderEnabled) return !1;
                var _suppressChladni = vortexTime > VORTEX_RAMP_TIME || flingTimer > 0 || fissionMode !== 'unified';
                scrollBlocked.left =
                    scrollBlocked.right =
                    scrollBlocked.up =
                    scrollBlocked.down =
                        0;
                var o = Math.min(Math.round(5), coneSeeds.length);
                if (!_suppressChladni && ((chladniModeTime += 2 * e), chladniNeedsAssign)) {
                    for (var t = 0, a = 0, r = 0; r < o; r++)
                        ((t += coneSeeds[r].px), (a += coneSeeds[r].py));
                    var l = generatePattern(chladniModeIdx, o, (t /= o), (a /= o));
                    for (chladniTargetFrom = [], r = 0; r < o; r++) {
                        var i = chladniTargets[r];
                        chladniTargetFrom[r] = i
                            ? { ux: i.ux, uy: i.uy }
                            : { ux: coneSeeds[r].px, uy: coneSeeds[r].py };
                    }
                    ((chladniTargetTo = farthestAssign(l, o)),
                        (chladniTargetT = 0),
                        (chladniModeTime = 0),
                        (chladniNeedsAssign = !1));
                }
                var c = 0;
                for (r = 0; r < o; r++) {
                    var s = coneSeeds[r],
                        f = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
                    f > c && (c = f);
                }
                if (!_suppressChladni && chladniModeTime >= CHLADNI_TARGET_DUR + CHLADNI_HOLD / (1 + 100 * c))
                    return (
                        (chladniModeIdx = (chladniModeIdx + 1) % chladniPatterns.length),
                        (chladniNeedsAssign = !0),
                        !0
                    );
                if (!_suppressChladni && chladniTargetT < 1) {
                    var d = Math.min(chladniModeTime / CHLADNI_TARGET_DUR, 1);
                    for (
                        chladniTargetT = d < 0.5 ? 2 * d * d : 1 - Math.pow(-2 * d + 2, 2) / 2,
                            r = 0;
                        r < o;
                        r++
                    ) {
                        var u = chladniTargetFrom[r],
                            g = chladniTargetTo[r];
                        u &&
                            g &&
                            (chladniTargets[r] = {
                                ux: u.ux + (g.ux - u.ux) * chladniTargetT,
                                uy: u.uy + (g.uy - u.uy) * chladniTargetT,
                            });
                    }
                }
                var p = !1,
                    h = 8 * coneRad,
                    m = Math.min(e, 0.033);
                for (r = 0; r < o; r++) {
                    ((s = coneSeeds[r]),
                        (i = chladniTargets[r] || { ux: scrollX + 0.25, uy: scrollY + 0.25 }));
                    var v = 8 + Math.min(80 * n, 20);
                    if (fissionMode === 'split' || fissionMode === 'merging') {
                        if (coneGroup[r] === 0) {
                            v *= PREDATOR_SPRING_MULT;
                        } else {
                            v *= 1.5;
                        }
                    }
                    ((s.vx += (i.ux - s.px) * v * m), (s.vy += (i.uy - s.py) * v * m));
                    for (var T = 3 * coneRad, x = 0; x < o; x++)
                        if (r !== x) {
                            var b,
                                D = s.px - coneSeeds[x].px,
                                w = s.py - coneSeeds[x].py,
                                R = Math.sqrt(D * D + w * w);
                            if (R < h && R > 1e-4)
                                (R < T
                                    ? ((b = (0.8 * m) / (R * R * R)), (b = Math.min(b, 15 * m)))
                                    : (b = (0.04 * (1 - (R - T) / (h - T)) * m) / R),
                                    (s.vx += (D / R) * b),
                                    (s.vy += (w / R) * b));
                        }
                    var dampBase = 0.9 + 0.08 * Math.min(flingTimer / VORTEX_FLING_DURATION, 1);
                    var E = Math.pow(dampBase, 60 * m);
                    ((s.vx *= E), (s.vy *= E));
                    var S = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
                    var speedCap = 0.2 * maxSpeed * (1 + 2 * Math.min(flingTimer / VORTEX_FLING_DURATION, 1));
                    S > speedCap && ((s.vx = (s.vx / S) * speedCap), (s.vy = (s.vy / S) * speedCap));
                    var U = s.px + s.vx * m,
                        y = s.py + s.vy * m,
                        F = 0.225,
                        A = scrollX + 0.25,
                        L = scrollY + 0.25,
                        P = U - A,
                        C = (y - L) * aspYX,
                        k = Math.sqrt(P * P + C * C);
                    if (k > F) {
                        ((U = A + (P / k) * F), (y = L + ((C / k) * F) / aspYX));
                        var _ = ((O = s.vx) * P + (Y = s.vy * aspYX) * C) / k;
                        _ > 0 && ((s.vx -= (_ * P) / k), (s.vy -= (_ * C) / k / aspYX));
                    }
                    var collisionTension = 0;
                    var collisionNX = 0, collisionNY = 0;
                    for (
                        var H = 0.04,
                            M = worldToScreenX(U),
                            X = worldToScreenY(y) * aspYX,
                            V = !1,
                            I = 0;
                        I < 3;
                        I++
                    ) {
                        for (var G = !1, B = 0; B < colliders.length; B++) {
                            var W,
                                N = colliders[B];
                            if (
                                (W =
                                    0 === N.type
                                        ? circleVsRect(
                                              M,
                                              X,
                                              H,
                                              N.cx,
                                              N.cy * aspYX,
                                              N.hx,
                                              N.hy * aspYX,
                                          )
                                        : 1 === N.type
                                          ? circleVsRotRect(
                                                M,
                                                X,
                                                H,
                                                N.cx,
                                                N.cy * aspYX,
                                                N.hx,
                                                N.hy,
                                                0.7071068,
                                                0.7071068,
                                            )
                                          : circleVsCircle(M, X, H, N.cx, N.cy * aspYX, N.rx))
                            ) {
                                ((M += W.nx * W.pen), (X += W.ny * W.pen));
                                var O = s.vx,
                                    Y = s.vy * aspYX,
                                    z = O * W.nx + Y * W.ny;
                                (z < 0 && ((collisionTension += -z), (collisionNX += W.nx * -z), (collisionNY += W.ny * -z), (s.vx -= z * W.nx), (s.vy -= (z * W.ny) / aspYX)),
                                    (G = !0),
                                    (V = !0));
                            }
                        }
                        if (!G) break;
                    }
                    if (((U = screenToWorldX(M)), (y = screenToWorldY(X / aspYX)), V)) {
                        var q = U - A,
                            j = (y - L) * aspYX,
                            K = Math.sqrt(q * q + j * j),
                            $ = 0.03,
                            J = F - 0.02;
                        if (K > J - $) {
                            var Q = Math.min(1, (K - (J - $)) / $);
                            (q < 0 && (scrollBlocked.left = Math.max(scrollBlocked.left, Q)),
                                q > 0 && (scrollBlocked.right = Math.max(scrollBlocked.right, Q)),
                                j < 0 && (scrollBlocked.up = Math.max(scrollBlocked.up, Q)),
                                j > 0 && (scrollBlocked.down = Math.max(scrollBlocked.down, Q)));
                        }
                    }
                    // Normalize accumulated collision normal
                    var cnLen = Math.sqrt(collisionNX * collisionNX + collisionNY * collisionNY);
                    if (cnLen > 0.001) {
                        collisionNX /= cnLen;
                        collisionNY /= cnLen;
                    }
                    // Smooth squash tracking from collision tension
                    var targetSquash = Math.min(collisionTension * 8.0, squashAmount);
                    var squashRate = collisionTension > 0.001 ? 12.0 : 5.0;
                    s.squash += (targetSquash - s.squash) * Math.min(squashRate * m, 1);
                    // Smooth squash direction (same rate as squash amount)
                    if (collisionTension > 0.001) {
                        var dirRate = Math.min(squashRate * m, 1);
                        s.squashNX += (collisionNX - s.squashNX) * dirRate;
                        s.squashNY += (collisionNY - s.squashNY) * dirRate;
                        var sLen = Math.sqrt(s.squashNX * s.squashNX + s.squashNY * s.squashNY);
                        if (sLen > 0.001) {
                            s.squashNX /= sLen;
                            s.squashNY /= sLen;
                        }
                    } else {
                        var dirDecay = Math.min(5.0 * m, 1);
                        s.squashNX *= (1 - dirDecay);
                        s.squashNY *= (1 - dirDecay);
                    }
                    if (s.px !== U || s.py !== y) {
                        ((s.px = U), (s.py = y));
                        var Z = s.px - (scrollX + 0.25),
                            ee = s.py - (scrollY + 0.25);
                        ((s.angle = Math.atan2(ee, Z)),
                            (s.dist = Math.sqrt(Z * Z + ee * ee) / 0.15),
                            (p = !0));
                    }
                }
                return p;
            }
            function createFlowFBO() {
                var e = gl.createTexture();
                (gl.bindTexture(gl.TEXTURE_2D, e),
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, W, H, 0, gl.RGBA, gl.FLOAT, null),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT));
                var n = gl.createFramebuffer();
                return (
                    gl.bindFramebuffer(gl.FRAMEBUFFER, n),
                    gl.framebufferTexture2D(
                        gl.FRAMEBUFFER,
                        gl.COLOR_ATTACHMENT0,
                        gl.TEXTURE_2D,
                        e,
                        0,
                    ),
                    { tex: e, fbo: n }
                );
            }
            !(function () {
                for (
                    var e = Math.min(Math.round(5), coneSeeds.length),
                        n = scrollX + 0.25,
                        o = scrollY + 0.25,
                        t = generatePattern(0, e, n, o),
                        a = 0,
                        r = 0;
                    r < t.length;
                    r++
                ) {
                    var l = t[r].ux - n,
                        i = t[r].uy - o,
                        c = Math.sqrt(l * l + i * i);
                    c > a && (a = c);
                }
                var s = Math.max(0.5 * a, 0.02);
                for (r = 0; r < e; r++) {
                    var f = (2 * Math.PI * r) / e;
                    ((coneSeeds[r].px = n + s * Math.cos(f)),
                        (coneSeeds[r].py = o + s * Math.sin(f)),
                        (coneSeeds[r].splatX = coneSeeds[r].px),
                        (coneSeeds[r].splatY = coneSeeds[r].py),
                        (coneSeeds[r].tipX = coneSeeds[r].px),
                        (coneSeeds[r].tipY = coneSeeds[r].py));
                }
                for (chladniTargetFrom = [], r = 0; r < e; r++)
                    chladniTargetFrom[r] = { ux: coneSeeds[r].px, uy: coneSeeds[r].py };
                for (chladniTargetTo = farthestAssign(t, e), chladniTargets = [], r = 0; r < e; r++)
                    chladniTargets[r] = { ux: coneSeeds[r].px, uy: coneSeeds[r].py };
                ((chladniTargetT = 0), (chladniModeTime = 0));
            })();
            var flowA = createFlowFBO(),
                flowB = createFlowFBO();
            function clearFlowField() {
                var e = new Float32Array(W * H * 4);
                (gl.bindTexture(gl.TEXTURE_2D, flowA.tex),
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, W, H, gl.RGBA, gl.FLOAT, e),
                    gl.bindTexture(gl.TEXTURE_2D, flowB.tex),
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, W, H, gl.RGBA, gl.FLOAT, e));
            }
            function createThickFBO() {
                var e = gl.createTexture();
                (gl.bindTexture(gl.TEXTURE_2D, e),
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG32F, W, H, 0, gl.RG, gl.FLOAT, null),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT));
                var n = gl.createFramebuffer();
                return (
                    gl.bindFramebuffer(gl.FRAMEBUFFER, n),
                    gl.framebufferTexture2D(
                        gl.FRAMEBUFFER,
                        gl.COLOR_ATTACHMENT0,
                        gl.TEXTURE_2D,
                        e,
                        0,
                    ),
                    { tex: e, fbo: n }
                );
            }
            clearFlowField();
            var thickA = createThickFBO(),
                thickB = createThickFBO();
            function clearThickness() {
                var e = new Float32Array(W * H * 2);
                (gl.bindTexture(gl.TEXTURE_2D, thickA.tex),
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, W, H, gl.RG, gl.FLOAT, e),
                    gl.bindTexture(gl.TEXTURE_2D, thickB.tex),
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, W, H, gl.RG, gl.FLOAT, e));
            }
            clearThickness();
            var RD_W = 2 * W,
                RD_H = 2 * H;
            function createRDFBO() {
                var e = gl.createTexture();
                (gl.bindTexture(gl.TEXTURE_2D, e),
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG32F, RD_W, RD_H, 0, gl.RG, gl.FLOAT, null),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT));
                var n = gl.createFramebuffer();
                return (
                    gl.bindFramebuffer(gl.FRAMEBUFFER, n),
                    gl.framebufferTexture2D(
                        gl.FRAMEBUFFER,
                        gl.COLOR_ATTACHMENT0,
                        gl.TEXTURE_2D,
                        e,
                        0,
                    ),
                    { tex: e, fbo: n }
                );
            }
            var rdA = createRDFBO(),
                rdB = createRDFBO(),
                rdNoiseTex = gl.createTexture();
            !(function () {
                var e = 512,
                    n = new Float32Array(e * e);
                function o(e) {
                    return e - 289 * Math.floor(e / 289);
                }
                function t(e) {
                    return o((34 * e + 1) * e);
                }
                function a(e, n) {
                    var a = 0.211324865405187,
                        r = 0.366025403784439,
                        l = -0.577350269189626,
                        i = 0.024390243902439,
                        c = Math.floor(e + (e + n) * r),
                        s = Math.floor(n + (e + n) * r),
                        f = e - c + (c + s) * a,
                        d = n - s + (c + s) * a,
                        u = f > d ? 1 : 0,
                        g = f > d ? 0 : 1,
                        p = f + a - u,
                        h = d + a - g,
                        m = f + l,
                        v = d + l;
                    c = o(c);
                    var T = t(t((s = o(s))) + c),
                        x = t(t(s + g) + c + u),
                        b = t(t(s + 1) + c + 1),
                        D = Math.max(0, 0.5 - f * f - d * d),
                        w = Math.max(0, 0.5 - p * p - h * h),
                        R = Math.max(0, 0.5 - m * m - v * v);
                    ((D *= D), (D *= D), (w *= w), (w *= w), (R *= R), (R *= R));
                    var E = ((T * i) % 1) * 2 - 1,
                        S = Math.abs(E) - 0.5,
                        U = E - Math.floor(E + 0.5),
                        y = ((x * i) % 1) * 2 - 1,
                        F = Math.abs(y) - 0.5,
                        A = y - Math.floor(y + 0.5),
                        L = ((b * i) % 1) * 2 - 1,
                        P = Math.abs(L) - 0.5,
                        C = L - Math.floor(L + 0.5);
                    return (
                        130 *
                        ((D *= 1.79284291400159 - 0.85373472095314 * (U * U + S * S)) *
                            (U * f + S * d) +
                            (w *= 1.79284291400159 - 0.85373472095314 * (A * A + F * F)) *
                                (A * p + F * h) +
                            (R *= 1.79284291400159 - 0.85373472095314 * (C * C + P * P)) *
                                (C * m + P * v))
                    );
                }
                for (var r = 0; r < e; r++)
                    for (var l = 0; l < e; l++) {
                        var i = (l + 0.5) / e,
                            c = (r + 0.5) / e;
                        n[r * e + l] =
                            0.5 * a(5 * i, 5 * c) +
                            0.3 * a(13 * i + 50, 13 * c + 50) +
                            0.2 * a(25 * i + 100, 25 * c + 100);
                    }
                (gl.bindTexture(gl.TEXTURE_2D, rdNoiseTex),
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, e, e, 0, gl.RED, gl.FLOAT, n),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT));
            })();
            var rdInitData = new Float32Array(RD_W * RD_H * 2);
            function seedRD() {
                for (var e = 0; e < RD_W * RD_H; e++)
                    ((rdInitData[2 * e] = 1), (rdInitData[2 * e + 1] = 0));
                var n = 42;
                function o() {
                    return (65535 & (n = (1103515245 * n + 12345) & 2147483647)) / 65535;
                }
                for (var t = 0; t < 600; t++)
                    for (
                        var a = Math.floor(o() * RD_W),
                            r = Math.floor(o() * RD_H),
                            l = Math.floor(3 * o()) + 3,
                            i = -l;
                        i <= l;
                        i++
                    )
                        for (var c = -l; c <= l; c++)
                            if (c * c + i * i <= l * l) {
                                var s =
                                    2 *
                                    (((((r + i) % RD_H) + RD_H) % RD_H) * RD_W +
                                        ((((a + c) % RD_W) + RD_W) % RD_W));
                                ((rdInitData[s] = 0.5), (rdInitData[s + 1] = 0.25));
                            }
                (gl.bindTexture(gl.TEXTURE_2D, rdA.tex),
                    gl.texSubImage2D(
                        gl.TEXTURE_2D,
                        0,
                        0,
                        0,
                        RD_W,
                        RD_H,
                        gl.RG,
                        gl.FLOAT,
                        rdInitData,
                    ),
                    gl.bindTexture(gl.TEXTURE_2D, rdB.tex),
                    gl.texSubImage2D(
                        gl.TEXTURE_2D,
                        0,
                        0,
                        0,
                        RD_W,
                        RD_H,
                        gl.RG,
                        gl.FLOAT,
                        rdInitData,
                    ));
            }
            seedRD();
            var PCB_W = Math.ceil(1.3 * W),
                PCB_H = Math.ceil(1.3 * H),
                pcbFBO = (function () {
                    var e = gl.createTexture();
                    (gl.bindTexture(gl.TEXTURE_2D, e),
                        gl.texImage2D(
                            gl.TEXTURE_2D,
                            0,
                            gl.RGBA16F,
                            PCB_W,
                            PCB_H,
                            0,
                            gl.RGBA,
                            gl.HALF_FLOAT,
                            null,
                        ),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));
                    var n = gl.createFramebuffer();
                    return (
                        gl.bindFramebuffer(gl.FRAMEBUFFER, n),
                        gl.framebufferTexture2D(
                            gl.FRAMEBUFFER,
                            gl.COLOR_ATTACHMENT0,
                            gl.TEXTURE_2D,
                            e,
                            0,
                        ),
                        { tex: e, fbo: n }
                    );
                })(),
                OBS_W = W,
                OBS_H = H,
                obsFBO = (function () {
                    var e = gl.createTexture();
                    (gl.bindTexture(gl.TEXTURE_2D, e),
                        gl.texImage2D(
                            gl.TEXTURE_2D,
                            0,
                            gl.RG16F,
                            OBS_W,
                            OBS_H,
                            0,
                            gl.RG,
                            gl.HALF_FLOAT,
                            null,
                        ),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT));
                    var n = gl.createFramebuffer();
                    return (
                        gl.bindFramebuffer(gl.FRAMEBUFFER, n),
                        gl.framebufferTexture2D(
                            gl.FRAMEBUFFER,
                            gl.COLOR_ATTACHMENT0,
                            gl.TEXTURE_2D,
                            e,
                            0,
                        ),
                        { tex: e, fbo: n }
                    );
                })(),
                CHIP_DATA_W = 64,
                CHIP_DATA_H = 64,
                COARSE_DATA_W = 16,
                COARSE_DATA_H = 16,
                chipDataBuf = new Float32Array(CHIP_DATA_W * CHIP_DATA_H * 4),
                coarseDataBuf = new Float32Array(COARSE_DATA_W * COARSE_DATA_H * 4),
                chipDataTex = gl.createTexture();
            (gl.bindTexture(gl.TEXTURE_2D, chipDataTex),
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGBA32F,
                    CHIP_DATA_W,
                    CHIP_DATA_H,
                    0,
                    gl.RGBA,
                    gl.FLOAT,
                    null,
                ),
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST),
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST),
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE),
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));
            var coarseDataTex = gl.createTexture();
            (gl.bindTexture(gl.TEXTURE_2D, coarseDataTex),
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGBA32F,
                    COARSE_DATA_W,
                    COARSE_DATA_H,
                    0,
                    gl.RGBA,
                    gl.FLOAT,
                    null,
                ),
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST),
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST),
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE),
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));
            var cellGridInfo = { chipMinGX: 0, chipMinGY: 0, coarseMinGX: 0, coarseMinGY: 0 },
                FIELD_SCALE = 2,
                VIS_HALF = 0.5 / FIELD_SCALE,
                viewZoom = 1.0,
                viewZoomTarget = 1.0,
                VIEW_ZOOM_MIN = 0.75,
                VIEW_ZOOM_MAX = 4.0,
                VIEW_ZOOM_SPEED = 0.1;
            function getVisScale() { return 0.5 / viewZoom; }
            var mouseDown = !1,
                mouseX = 0.5,
                mouseY = 0.5,
                hoverX = 0.5,
                hoverY = 0.5,
                hoverFieldX = 0.5,
                hoverFieldY = 0.5,
                hoverVelX = 0,
                hoverVelY = 0,
                prevHoverX = 0.5,
                prevHoverY = 0.5,
                hoverActive = false,
                mouseDownX = 0,
                mouseDownY = 0,
                maxSpeed = 20.0,
                squashAmount = 0.65, // 0 = no flattening, 1 = max flattening
                wasMovingInput = !1,
                // Vortex drain state
                vortexTime = 0,
                vortexCenterX = 0.5,
                vortexCenterY = 0.5,
                vortexAngle = 0,
                vortexOmega = 0,
                prevMouseX = 0.5,
                prevMouseY = 0.5,
                flingTimer = 0,
                explosionTimer = 0,
                explosionCenterX = 0.5,
                explosionCenterY = 0.5,
                EXPLOSION_FLOW_DURATION = 0.5,
                VORTEX_STILL_THRESH = 0.005,
                VORTEX_RAMP_TIME = 0.3,
                VORTEX_MAX_OMEGA = 14.0,
                VORTEX_MIN_RADIUS = 0.04,
                VORTEX_MAX_RADIUS = 0.10,
                VORTEX_FLING_DURATION = 0.8,
                VORTEX_FLING_BOOST = 4.0,
                // Heartbeat pulse state
                heartPhase = 0,
                heartRate = 0.8,
                heartAmplitude = 0.03,
                heartExcitement = 0,
                heartPulse = 0,
                heartPulsePositive = 0, // rectified pulse (0-1), only systole
                // Tap detection
                mouseDownTime = 0,
                tapRings = [],
                TAP_MAX_DURATION = 0.25,
                TAP_MAX_MOVE = 0.03,
                TAP_RING_SPEED = 0.15,
                TAP_RING_LIFETIME = 0.8,
                TAP_RING_MAX = 4,
                // Fission state
                fissionMode = 'unified',  // 'unified', 'split', 'merging'
                fissionBuildup = 0,
                fissionTimer = 0,
                coneGroup = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],  // 0=predator, 1=prey
                FISSION_SPEED_THRESH = 0.06,
                FISSION_BUILDUP_RATE = 3.0,
                FISSION_TRIGGER = 1.0,
                FISSION_DECAY_RATE = 1.5,
                FISSION_SPLIT_DURATION = 4.0,
                FISSION_MERGE_DURATION = 1.5,
                fissionMergeT = 0,
                preyJitterPhase = 0,
                preyJitterFreq = 8.0,
                PREDATOR_SPRING_MULT = 3.0,
                PREY_ESCAPE_RADIUS = 0.15;
            (canvas.addEventListener('pointerdown', function (e) {
                ((mouseDown = !0), canvas.setPointerCapture(e.pointerId));
                var n = canvas.getBoundingClientRect();
                ((mouseX = (e.clientX - n.left) / n.width),
                    (mouseY = 1 - (e.clientY - n.top) / n.height),
                    (mouseDownX = mouseX),
                    (mouseDownY = mouseY),
                    (mouseDownTime = performance.now() / 1000),
                    e.preventDefault());
            }),
                canvas.addEventListener('pointermove', function (e) {
                    var n = canvas.getBoundingClientRect();
                    hoverX = (e.clientX - n.left) / n.width;
                    hoverY = 1 - (e.clientY - n.top) / n.height;
                    hoverActive = true;
                    if (mouseDown) {
                        ((mouseX = hoverX),
                            (mouseY = hoverY),
                            e.preventDefault());
                    }
                }),
                canvas.addEventListener('pointerup', function (e) {
                    // Tap detection: short duration + small movement
                    var tapDuration = performance.now() / 1000 - mouseDownTime;
                    var tapDx = mouseX - mouseDownX, tapDy = mouseY - mouseDownY;
                    var tapDist = Math.sqrt(tapDx * tapDx + tapDy * tapDy);
                    if (tapDuration < TAP_MAX_DURATION && tapDist < TAP_MAX_MOVE) {
                        // Register tap ring at field UV position
                        var tapFieldX = screenToWorldX(mouseX);
                        var tapFieldY = screenToWorldY(mouseY);
                        tapRings.push({ fx: tapFieldX, fy: tapFieldY, age: 0 });
                        if (tapRings.length > TAP_RING_MAX) tapRings.shift();
                        // Radial impulse to nearby cones
                        var tapWorldX = screenToWorldX(mouseX);
                        var tapWorldY = screenToWorldY(mouseY);
                        var coneCount = Math.min(Math.round(5), coneSeeds.length);
                        for (var ti = 0; ti < coneCount; ti++) {
                            var cone = coneSeeds[ti];
                            var dx = cone.px - tapWorldX, dy = cone.py - tapWorldY;
                            var dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0.001 && dist < 0.15) {
                                var impulse = 0.8 * (1 - dist / 0.15);
                                cone.vx += (dx / dist) * impulse;
                                cone.vy += (dy / dist) * impulse;
                            }
                        }
                        // Excitement spike from tap
                        heartExcitement = Math.min(heartExcitement + 0.5, 1);
                    }
                    ((mouseDown = !1), e.preventDefault());
                }),
                canvas.addEventListener('pointercancel', function (e) {
                    ((mouseDown = !1), e.preventDefault());
                }));
            canvas.addEventListener('pointerleave', function () {
                hoverActive = false;
            });
            canvas.addEventListener('pointerenter', function (e) {
                var n = canvas.getBoundingClientRect();
                hoverX = (e.clientX - n.left) / n.width;
                hoverY = 1 - (e.clientY - n.top) / n.height;
                hoverActive = true;
            });
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                var rect = canvas.getBoundingClientRect();
                var cursorX = (e.clientX - rect.left) / rect.width;
                var cursorY = 1 - (e.clientY - rect.top) / rect.height;
                var zoomDelta = -e.deltaY * 0.001;
                var oldZoom = viewZoomTarget;
                viewZoomTarget = Math.max(VIEW_ZOOM_MIN,
                                 Math.min(VIEW_ZOOM_MAX, viewZoomTarget * (1 + zoomDelta)));
                var oldVisScale = 0.5 / oldZoom;
                var newVisScale = 0.5 / viewZoomTarget;
                var cursorFieldX = cursorX * oldVisScale + scrollX;
                var cursorFieldY = cursorY * oldVisScale + scrollY;
                scrollX = cursorFieldX - cursorX * newVisScale;
                scrollY = cursorFieldY - cursorY * newVisScale;
            }, { passive: false });
            var arrowKeys = { left: !1, right: !1, up: !1, down: !1 };
            (window.addEventListener('keydown', function (e) {
                ('ArrowLeft' === e.key && (arrowKeys.left = !0),
                    'ArrowRight' === e.key && (arrowKeys.right = !0),
                    'ArrowUp' === e.key && (arrowKeys.up = !0),
                    'ArrowDown' === e.key && (arrowKeys.down = !0));
            }),
                window.addEventListener('keyup', function (e) {
                    ('ArrowLeft' === e.key && (arrowKeys.left = !1),
                        'ArrowRight' === e.key && (arrowKeys.right = !1),
                        'ArrowUp' === e.key && (arrowKeys.up = !1),
                        'ArrowDown' === e.key && (arrowKeys.down = !1));
                }));
            var flowUpdateFragSrc =
                    '#version 300 es\n    precision highp float;\n    in vec2 vUV;\n    uniform sampler2D uFlow;\n    uniform vec2 uTexel;       // 1/W, 1/H\n    const float uDecay = 1.0;\n    uniform float uDiffuse;\n    uniform vec2 uScrollOffset; // current scroll in UV\n    uniform float uVisHalf;    // half visible window in field UV (0.25 for 2x field)\n    uniform vec2 uAspect;      // (1.0, W/H) for aspect-ratio corrected eraser arc\n    uniform float uAspectYX;   // H/W for circular cone splats\n    uniform vec2 uScrollVel;   // scroll velocity in field UV/s (zero when idle)\n    // Cone splats\n    uniform int uConeCount;\n    uniform vec4 uCones[15];   // xy = UV position (field space), zw = velocity\n    uniform float uConeRadius;\n    uniform float uConeSquash[15];\n    uniform vec2 uConeSquashDir[15];\n    uniform float uSplatScale;\n    uniform float uMaxSpeed;\n    uniform sampler2D uObs;  // obstacle map (R=height, G=matID)\n    uniform vec2 uVortexPos;\n    uniform float uVortexStr;\n    uniform vec2 uHeartCenter;  // blob center in field UV\n    uniform float uHeartFlow;   // radial flow burst strength (0-1)\n    uniform vec2 uHoverPos;\n    uniform float uHoverStr;\n    uniform vec2 uHoverVel;\n    uniform vec2 uExplosionPos;\n    uniform float uExplosionStr;\n    out vec4 fragFlow;\n\n    // Smooth obstacle strength from height (0=open, 1=solid wall)\n    float wallStr(vec2 fuv) {\n        float h = texture(uObs, fuv).r;\n        return smoothstep(0.0, 0.008, h);  // smooth transition over height falloff\n    }\n\n    void main() {\n        float wall = wallStr(vUV);\n\n        vec2 flow = texture(uFlow, vUV).rg;\n\n        // Offscreen distance factor (used for diffusion boost and eraser)\n        vec2 visCenter = uScrollOffset + uVisHalf;\n        vec2 delta = vUV - visCenter;\n        delta = delta - round(delta); // wrap to [-0.5, 0.5]\n        float offDist = length(delta);\n        float offT = clamp((offDist - uVisHalf) / (0.5 - uVisHalf), 0.0, 1.0);\n\n        // 4-neighbor wall-aware diffusion (boosted offscreen for natural blur of old trails)\n        vec2 uvE = vUV + vec2(uTexel.x, 0.0);\n        vec2 uvW = vUV - vec2(uTexel.x, 0.0);\n        vec2 uvN = vUV + vec2(0.0, uTexel.y);\n        vec2 uvS = vUV - vec2(0.0, uTexel.y);\n        float wE = 1.0 - wallStr(uvE);\n        float wW = 1.0 - wallStr(uvW);\n        float wN = 1.0 - wallStr(uvN);\n        float wS = 1.0 - wallStr(uvS);\n        float wSum = wE + wW + wN + wS;\n        vec2 avg;\n        if (wSum > 0.0) {\n            avg = (texture(uFlow, uvE).rg * wE +\n                   texture(uFlow, uvW).rg * wW +\n                   texture(uFlow, uvN).rg * wN +\n                   texture(uFlow, uvS).rg * wS) / wSum;\n        } else {\n            avg = flow;\n        }\n        flow = mix(flow, avg, uDiffuse + offT * 0.3);\n\n        // Decay\n        flow *= uDecay;\n\n        // Cone splats: paint velocity direction onto field (mix = overwrite with edge bleed)\n        // uConeRadius is in window UV; field is 2x window, so * 0.25 makes\n        // the visible trail (~2 sigma on screen) match the debug circle diameter\n        for (int i = 0; i < 15; i++) {\n            if (i >= uConeCount) break;\n            float sq = uConeSquash[i];\n            float splatR = uConeRadius * 0.25 * uSplatScale;\n            float sr2 = splatR * splatR;\n            vec2 coneFieldUV = uCones[i].xy;  // already field UV\n            vec2 coneVel = uCones[i].zw;\n            float speed = length(coneVel);\n            if (speed < 0.0001) continue;\n            vec2 dir = coneVel / speed;\n            vec2 d = vUV - coneFieldUV;\n            d = d - round(d);\n            d.y *= uAspectYX;\n            vec2 sqDir = uConeSquashDir[i];\n            float sqDirLen = length(sqDir);\n            float dist2;\n            if (sq > 0.01 && sqDirLen > 0.01) {\n                vec2 n = sqDir / sqDirLen;\n                float stretchFactor = 1.0 / max(1.0 - sq, 0.35);\n                float alongN = dot(d, n);\n                vec2 perpN = d - alongN * n;\n                dist2 = dot(perpN, perpN) / stretchFactor + alongN * alongN * stretchFactor;\n            } else {\n                dist2 = dot(d, d);\n            }\n            if (dist2 < sr2 * 9.0) {\n                float g = exp(-dist2 / (2.0 * sr2));\n                flow = mix(flow, dir, g * min(speed * 10.0 / uMaxSpeed, 1.0));\n            }\n        }\n\n        // Vortex flow splat: tangential flow around vortex center\n        if (uVortexStr > 0.001) {\n            vec2 vd = vUV - uVortexPos;\n            vd = vd - round(vd);\n            vd.y *= uAspectYX;\n            float vDist = length(vd);\n            vec2 tangent = vec2(-vd.y, vd.x);\n            float tLen = length(tangent);\n            if (tLen > 0.0001) {\n                tangent /= tLen;\n                float vortexR = uConeRadius * 3.0;\n                float vr2 = vortexR * vortexR;\n                float g = exp(-vDist * vDist / (2.0 * vr2));\n                vec2 radial = -vd / max(vDist, 0.0001);\n                vec2 spiralDir = tangent * 0.9 + radial * 0.1;\n                spiralDir = normalize(spiralDir);\n                flow = mix(flow, spiralDir, g * uVortexStr);\n            }\n        }\n\n        // Offscreen clearing: directional eraser arc, only active when moving\n        // Reuses delta and offDist/offT computed above\n        float scrollSpeed = length(uScrollVel);\n        if (scrollSpeed > 0.0001) {\n            float t = offT;\n\n            // Direction: trailing hemisphere behind movement direction (90)\n            // Compute angle in aspect-corrected space so degrees match screen appearance\n            // Full strength within 60, ramp to zero by 90\n            vec2 aspDelta = delta * uAspect;\n            vec2 aspMoveDir = normalize(uScrollVel * uAspect);\n            float aspDist = length(aspDelta);\n            float d = (aspDist > 0.0001) ? dot(aspDelta / aspDist, aspMoveDir) : 0.0;\n            // negD = cos(angle from behind): 1.0 = directly behind, 0.0 = perpendicular\n            float negD = -d;\n            // smoothstep: 0 at 90 (perpendicular), ramp 9060, 1 within 60\n            float angleFactor = smoothstep(0.0, 0.5, negD);\n\n            // Combined: linear distance fade * angle modulation\n            float maxMag = 1.0 - angleFactor * t;\n            float mag = length(flow);\n            if (mag > maxMag) flow = (mag > 0.0001) ? flow / mag * maxMag : vec2(0.0);\n        }\n\n        // Heartbeat radial flow pulse: emanates outward from blob center\n        if (uHeartFlow > 0.001) {\n            vec2 hd = vUV - uHeartCenter;\n            hd = hd - round(hd);\n            hd.y *= uAspectYX;\n            float hDist = length(hd);\n            // Gaussian falloff centered on blob, wide enough to cover the fluid\n            float heartR = uConeRadius * 6.0;\n            float hg = exp(-hDist * hDist / (2.0 * heartR * heartR));\n            // Radial outward direction\n            if (hDist > 0.0001) {\n                vec2 radial = hd / hDist;\n                flow = mix(flow, radial, hg * uHeartFlow * 0.4);\n            }\n        }\n\n        // Explosion radial outward flow burst\n        if (uExplosionStr > 0.001) {\n            vec2 ed = vUV - uExplosionPos;\n            ed = ed - round(ed);\n            ed.y *= uAspectYX;\n            float eDist = length(ed);\n            if (eDist > 0.0001) {\n                vec2 radial = ed / eDist;\n                float explosionR = uConeRadius * 5.0;\n                float er2 = explosionR * explosionR;\n                float g = exp(-eDist * eDist / (2.0 * er2));\n                flow = mix(flow, radial, g * uExplosionStr);\n            }\n        }\n\n        // Cursor hover: gentle radial flow disturbance\n        if (uHoverStr > 0.001) {\n            vec2 hd = vUV - uHoverPos;\n            hd = hd - round(hd);\n            hd.y *= uAspectYX;\n            float hDist = length(hd);\n            float hoverR = uConeRadius * 4.0;\n            float hg = exp(-hDist * hDist / (2.0 * hoverR * hoverR));\n            if (hDist > 0.0001) {\n                vec2 radial = hd / hDist;\n                vec2 velDir = uHoverVel;\n                float velMag = length(velDir);\n                vec2 hoverFlow = radial;\n                if (velMag > 0.5) {\n                    velDir /= velMag;\n                    float velBlend = min(velMag / 5.0, 0.7);\n                    hoverFlow = mix(radial, velDir, velBlend);\n                    hoverFlow = normalize(hoverFlow);\n                }\n                flow = mix(flow, hoverFlow, hg * uHoverStr * 0.3);\n            }\n        }\n\n        // Wall attenuation AFTER cone splats (so obstacles always win)\n        flow *= 1.0 - wall;\n\n        fragFlow = vec4(flow, 0.0, 1.0);\n    }',
                flowUpdateProg = linkProg(vertSrc, flowUpdateFragSrc),
                flowLocs = {
                    flow: gl.getUniformLocation(flowUpdateProg, 'uFlow'),
                    texel: gl.getUniformLocation(flowUpdateProg, 'uTexel'),
                    diffuse: gl.getUniformLocation(flowUpdateProg, 'uDiffuse'),
                    scrollOffset: gl.getUniformLocation(flowUpdateProg, 'uScrollOffset'),
                    visHalf: gl.getUniformLocation(flowUpdateProg, 'uVisHalf'),
                    aspect: gl.getUniformLocation(flowUpdateProg, 'uAspect'),
                    aspectYX: gl.getUniformLocation(flowUpdateProg, 'uAspectYX'),
                    scrollVel: gl.getUniformLocation(flowUpdateProg, 'uScrollVel'),
                    coneCount: gl.getUniformLocation(flowUpdateProg, 'uConeCount'),
                    cones: [],
                    coneRadius: gl.getUniformLocation(flowUpdateProg, 'uConeRadius'),
                    splatScale: gl.getUniformLocation(flowUpdateProg, 'uSplatScale'),
                    maxSpeed: gl.getUniformLocation(flowUpdateProg, 'uMaxSpeed'),
                    obs: gl.getUniformLocation(flowUpdateProg, 'uObs'),
                    vortexPos: gl.getUniformLocation(flowUpdateProg, 'uVortexPos'),
                    vortexStr: gl.getUniformLocation(flowUpdateProg, 'uVortexStr'),
                    explosionPos: gl.getUniformLocation(flowUpdateProg, 'uExplosionPos'),
                    explosionStr: gl.getUniformLocation(flowUpdateProg, 'uExplosionStr'),
                    heartCenter: gl.getUniformLocation(flowUpdateProg, 'uHeartCenter'),
                    heartFlow: gl.getUniformLocation(flowUpdateProg, 'uHeartFlow'),
                    hoverPos: gl.getUniformLocation(flowUpdateProg, 'uHoverPos'),
                    hoverStr: gl.getUniformLocation(flowUpdateProg, 'uHoverStr'),
                    hoverVel: gl.getUniformLocation(flowUpdateProg, 'uHoverVel'),
                    coneSquash: [],
                    coneSquashDir: [],
                };
            for (ci = 0; ci < 15; ci++)
                flowLocs.cones.push(gl.getUniformLocation(flowUpdateProg, 'uCones[' + ci + ']'));
            for (ci = 0; ci < 15; ci++)
                flowLocs.coneSquash.push(gl.getUniformLocation(flowUpdateProg, 'uConeSquash[' + ci + ']'));
            for (ci = 0; ci < 15; ci++)
                flowLocs.coneSquashDir.push(gl.getUniformLocation(flowUpdateProg, 'uConeSquashDir[' + ci + ']'));
            var thickUpdateFragSrc =
                    '#version 300 es\n    precision highp float;\n    in vec2 vUV;\n    uniform sampler2D uThick;      // previous thickness\n    uniform sampler2D uFlow;       // flow field for advection\n    uniform vec2 uTexel;           // 1/W, 1/H\n    uniform float uDecay;          // thickness decay (0.95-1.0)\n    uniform float uDiffuse;        // thickness diffusion strength\n    const float uAdvect = 0.0;     // advection strength (disabled  fluid stays in place)\n    uniform vec2 uScrollVel;      // scroll velocity in field UV/s\n    uniform float uDt;            // frame delta time\n    uniform vec2 uScrollOffset;    // scroll position in field UV\n    uniform float uVisHalf;        // half visible window in field UV\n    // Cone emission\n    uniform int uConeCount;\n    uniform vec4 uCones[15];       // xy = UV pos (field space), zw = velocity\n    uniform float uConeRadius;\n    uniform float uConeSquash[15]; // per-cone squash factor (0=normal, 0.65=max flat)\n    uniform vec2 uConeSquashDir[15];\n    uniform float uConeEmit;       // emission height\n    uniform float uConeFalloff;    // edge falloff exponent (1=Gaussian, <1=mesa, >1=pointy)\n    uniform float uTrailHeight;    // max trail thickness (cones poke through above this)\n    uniform float uTipShape;       // tip exponent: 2=Gaussian(round), 1=sharp, 0.5=cusp, 4=flat-top\n    uniform float uAspectYX;       // H/W for circular cone splats\n    uniform sampler2D uObs;        // obstacle map (R=height, G=matID)\n    out vec4 fragThick;\n\n    // Smooth obstacle strength from height (0=open, 1=solid wall)\n    float wallStr(vec2 fuv) {\n        float h = texture(uObs, fuv).r;\n        return smoothstep(0.0, 0.008, h);\n    }\n\n    void main() {\n        float wall = wallStr(vUV);\n\n        // Semi-Lagrangian advection: trace back along flow to sample previous thickness\n        // Flow field stores normalized direction; scale by scroll speed for actual velocity\n        vec2 fieldUV = vUV;\n        vec2 flow = texture(uFlow, fieldUV).rg;\n        float flowMag = length(flow);\n        // Use scroll velocity magnitude to scale the advection distance\n        float scrollSpeed = length(uScrollVel);\n        vec2 vel = flow * scrollSpeed * uAdvect;\n        vec2 srcUV = fieldUV - vel * uDt;\n        // Blend advected source with current position based on wall strength at source\n        float srcWall = wallStr(srcUV);\n        srcUV = mix(srcUV, fieldUV, srcWall);\n        float thick = texture(uThick, srcUV).r;\n\n        // 4-neighbor wall-aware diffusion\n        vec2 uvE = vUV + vec2(uTexel.x, 0.0);\n        vec2 uvW = vUV - vec2(uTexel.x, 0.0);\n        vec2 uvN = vUV + vec2(0.0, uTexel.y);\n        vec2 uvS = vUV - vec2(0.0, uTexel.y);\n        float wE = 1.0 - wallStr(uvE);\n        float wW = 1.0 - wallStr(uvW);\n        float wN = 1.0 - wallStr(uvN);\n        float wS = 1.0 - wallStr(uvS);\n        float wSum = wE + wW + wN + wS;\n        float avg;\n        if (wSum > 0.0) {\n            avg = (texture(uThick, uvE).r * wE +\n                   texture(uThick, uvW).r * wW +\n                   texture(uThick, uvN).r * wN +\n                   texture(uThick, uvS).r * wS) / wSum;\n        } else {\n            avg = thick;\n        }\n        thick = mix(thick, avg, uDiffuse);\n\n        // Interior spreading: extra diffusion weighted by thickness.\n        // In the flat plateau center, avg  thick, so no effect.\n        // At the plateau edges, lower neighbors pull values down  dome.\n        // Near zero boundary: weight vanishes, so edge position is preserved.\n        float spreadW = smoothstep(uTrailHeight * 0.5, uTrailHeight * 0.8, thick);\n        thick = mix(thick, avg, spreadW);\n\n        // Decay\n        thick *= uDecay;\n\n        // Cap trail height so cones poke through the surface\n        thick = min(thick, uTrailHeight);\n\n        // Cone Gaussian splats using max blend (maintain solid cores)\n        // Also accumulate additive cone field for G channel (RD cone interaction)\n        float coneField = 0.0;\n        float topCone = 0.0;\n        float secondCone = 0.0;\n        for (int i = 0; i < 15; i++) {\n            if (i >= uConeCount) break;\n            float sq = uConeSquash[i];\n            float localEmit = uConeEmit * (1.0 - sq);\n            float splatR = uConeRadius * 0.5;\n            float sr2 = splatR * splatR;\n            vec2 coneFieldUV = uCones[i].xy;  // already field UV\n            vec2 d = vUV - coneFieldUV;\n            d = d - round(d); // wrap\n            d.y *= uAspectYX;\n            vec2 sqDir = uConeSquashDir[i];\n            float sqDirLen = length(sqDir);\n            float dist2;\n            if (sq > 0.01 && sqDirLen > 0.01) {\n                vec2 n = sqDir / sqDirLen;\n                float stretchFactor = 1.0 / max(1.0 - sq, 0.35);\n                float alongN = dot(d, n);\n                vec2 perpN = d - alongN * n;\n                dist2 = dot(perpN, perpN) / stretchFactor + alongN * alongN * stretchFactor;\n            } else {\n                dist2 = dot(d, d);\n            }\n            if (dist2 < sr2 * 16.0) {\n                float rNorm = pow(dist2 / sr2, uTipShape * 0.5);  // (r/)^tipShape\n                float g = localEmit * exp(-uConeFalloff * rNorm / 2.0);\n                thick = max(thick, g); // R: max blend, not additive\n                coneField += g;        // G: additive sum for cone height field\n                if (g > topCone) { secondCone = topCone; topCone = g; }\n                else if (g > secondCone) { secondCone = g; }\n            }\n        }\n        // Valley between overlapping cones: reduce thickness where two cones are similar strength\n        if (secondCone > 0.01) {\n            float valleyRatio = secondCone / max(topCone, 0.001);\n            float valleyStr = smoothstep(0.3, 0.8, valleyRatio) * 0.45;\n            thick *= 1.0 - valleyStr;\n        }\n\n        // Offscreen clearing: only clear near the wrap boundary so trails persist\n        // Trail history preserved from visible edge (uVisHalf) out to 0.4 UV\n        // Fade only in the last 0.1 UV before the wrap seam at 0.5\n        vec2 visCenter = uScrollOffset + uVisHalf;\n        vec2 delta = vUV - visCenter;\n        delta = delta - round(delta);\n        float offDist = length(delta);\n        float wrapFade = smoothstep(0.4, 0.5, offDist);\n        thick *= 1.0 - wrapFade;\n\n        // Wall attenuation AFTER cone emission (so obstacles always win)\n        thick *= 1.0 - wall;\n        // Cone field also fades at walls and offscreen\n        coneField *= (1.0 - wall) * (1.0 - wrapFade);\n\n        fragThick = vec4(thick, coneField, 0.0, 1.0);\n    }',
                thickUpdateProg = linkProg(vertSrc, thickUpdateFragSrc),
                thickLocs = {
                    thick: gl.getUniformLocation(thickUpdateProg, 'uThick'),
                    flow: gl.getUniformLocation(thickUpdateProg, 'uFlow'),
                    texel: gl.getUniformLocation(thickUpdateProg, 'uTexel'),
                    decay: gl.getUniformLocation(thickUpdateProg, 'uDecay'),
                    diffuse: gl.getUniformLocation(thickUpdateProg, 'uDiffuse'),
                    scrollVel: gl.getUniformLocation(thickUpdateProg, 'uScrollVel'),
                    dt: gl.getUniformLocation(thickUpdateProg, 'uDt'),
                    scrollOffset: gl.getUniformLocation(thickUpdateProg, 'uScrollOffset'),
                    visHalf: gl.getUniformLocation(thickUpdateProg, 'uVisHalf'),
                    coneCount: gl.getUniformLocation(thickUpdateProg, 'uConeCount'),
                    cones: [],
                    coneRadius: gl.getUniformLocation(thickUpdateProg, 'uConeRadius'),
                    coneEmit: gl.getUniformLocation(thickUpdateProg, 'uConeEmit'),
                    coneFalloff: gl.getUniformLocation(thickUpdateProg, 'uConeFalloff'),
                    trailHeight: gl.getUniformLocation(thickUpdateProg, 'uTrailHeight'),
                    tipShape: gl.getUniformLocation(thickUpdateProg, 'uTipShape'),
                    aspectYX: gl.getUniformLocation(thickUpdateProg, 'uAspectYX'),
                    obs: gl.getUniformLocation(thickUpdateProg, 'uObs'),
                    coneSquash: [],
                    coneSquashDir: [],
                };
            for (ci = 0; ci < 15; ci++)
                thickLocs.cones.push(gl.getUniformLocation(thickUpdateProg, 'uCones[' + ci + ']'));
            for (ci = 0; ci < 15; ci++)
                thickLocs.coneSquash.push(gl.getUniformLocation(thickUpdateProg, 'uConeSquash[' + ci + ']'));
            for (ci = 0; ci < 15; ci++)
                thickLocs.coneSquashDir.push(gl.getUniformLocation(thickUpdateProg, 'uConeSquashDir[' + ci + ']'));
            var rdUpdateFragSrc =
                    "#version 300 es\n    precision highp float;\n    in vec2 vUV;\n    uniform sampler2D uState;      // RD state (ping-pong)\n    uniform sampler2D uThick;      // thickness RG32F: R=thickness, G=cone height\n    uniform sampler2D uFlow;       // flow RGBA32F: RG=velocity direction\n    uniform sampler2D uNoise;      // prebaked noise (R32F)\n    uniform vec2 uTexel;           // 1/W, 1/H\n    uniform float uF, uK, uFCenter, uKCenter;\n    uniform float uDaMin, uDaMax, uDbRatio;\n    uniform float uAniso;\n    uniform float uGridScale;\n    uniform float uScaleClamp, uDecayWidth;\n    uniform float uFNoise, uKNoise, uFKRamp;\n    uniform float uConeDaBoost;\n    uniform float uConeEmit;\n    uniform float uEdgeCut;\n    uniform float uSwarmSpeed;\n    uniform float uSeedStr;\n    uniform float uSeedThr;\n    uniform float uSeedSpd;\n    uniform float uConeSpeed;\n    uniform float uSeedScale;\n    uniform float uAdvect;\n    uniform float uAdvDecay;\n    uniform float uTime;\n    uniform float uSimSpeed;\n    uniform float uHeartFKPulse;   // heartbeat F/K perturbation strength (0-1)\n    uniform vec2 uHeartCenterRD;   // blob center in field UV (for RD)\n    uniform float uHeartRadius;    // radius of effect in field UV\n    uniform vec2 uHoverPosRD;\n    uniform float uHoverRDStr;\n    out vec2 fragColor;\n\n    // Inline tensor: compute anisotropic diffusion from flow direction and thickness\n    // Scale thickness by 1/uConeEmit so RD sim sees 0-1 range matching rd-scale-test2's blob\n    float thickScale;  // set in main() before first flowTensor call\n    vec3 flowTensor(vec2 pos) {\n        float thick = min(texture(uThick, pos).r * thickScale, 1.0);\n        float Da = mix(uDaMin, uDaMax, thick);\n\n        vec2 flowVec = texture(uFlow, pos).rg;\n        float flowMag = length(flowVec);\n        // Time-varying noise direction  pattern never settles to equilibrium\n        float noiseAngle = texture(uNoise, pos * 2.0 + vec2(uTime * 0.02, uTime * 0.013)).r * 3.14159;\n        vec2 noiseDir = vec2(cos(noiseAngle), sin(noiseAngle));\n        float flowBlend = min(flowMag * 10.0, 1.0);\n        vec2 flowDir = (flowMag > 0.001) ? flowVec / flowMag : noiseDir;\n        vec2 baseDir = mix(noiseDir, flowDir, flowBlend);\n        // Rotate 90: diffuse faster ACROSS flow, not along it  coral instead of stripes\n        vec2 dir = vec2(-baseDir.y, baseDir.x);\n        float ratio = uAniso;\n\n        return Da * vec3(\n            ratio * dir.x*dir.x + dir.y*dir.y,\n            ratio * dir.y*dir.y + dir.x*dir.x,\n            (ratio - 1.0) * dir.x * dir.y\n        );\n    }\n\n    void main() {\n        vec2 st = vUV;\n        thickScale = 1.0 / uConeEmit;  // map cone thickness (0-emit) to 0-1 range\n\n        // Early exit: skip expensive computation where no fluid exists\n        // Saves ~14 texture reads + all ALU per pixel in empty regions\n        vec2 thickSample = texture(uThick, st).rg;\n        float rawThick = thickSample.r;\n        if (rawThick < 0.001) {\n            fragColor = texture(uState, st).rg;\n            return;\n        }\n\n        vec2 c = texture(uState, st).rg;\n        float a = c.r;\n        float b = c.g;\n\n        float thick = min(rawThick * thickScale, 1.0);  // scaled to 0-1\n        float coneMap = thickSample.g;\n\n        // Time-varying noise perturbation  slow drift prevents pattern from settling\n        float nPert = texture(uNoise, st + vec2(uTime * 0.01, uTime * 0.007)).r;\n\n        float tClamped = min(thick, 0.85);\n\n        // F/K: interpolate from edge to center values based on scaled thickness\n        float fkT = pow(tClamped, uFKRamp);\n        float F = mix(uF, uFCenter, fkT) + nPert * uFNoise;\n        float K = mix(uK, uKCenter, fkT) + nPert * uKNoise;\n\n        // Heartbeat pulse: temporarily perturb F/K to destabilize pattern near center\n        if (uHeartFKPulse > 0.001) {\n            vec2 hd = st - uHeartCenterRD;\n            hd = hd - round(hd);\n            float hDist = length(hd);\n            float hMask = exp(-hDist * hDist / (2.0 * uHeartRadius * uHeartRadius));\n            // Boost F (more feeding = patterns expand/split)\n            // Lower K slightly (less killing = patterns thicken)\n            F += hMask * uHeartFKPulse * 0.008;\n            K -= hMask * uHeartFKPulse * 0.002;\n        }\n\n        // Cursor hover: subtle F/K perturbation near cursor\n        if (uHoverRDStr > 0.001) {\n            vec2 hovd = st - uHoverPosRD;\n            hovd = hovd - round(hovd);\n            float hovDist = length(hovd);\n            float hovR = 0.04;\n            float hovMask = exp(-hovDist * hovDist / (2.0 * hovR * hovR));\n            F += hovMask * uHoverRDStr * 0.004;\n            K -= hovMask * uHoverRDStr * 0.001;\n        }\n\n        // Thickness-dependent grid scale (using scaled thickness)\n        float gridScale = mix(1.0, uGridScale, thick);\n        float dt = uSimSpeed / (gridScale * gridScale);\n        vec2 ddx = vec2(uTexel.x, 0.0) * gridScale;\n        vec2 ddy = vec2(0.0, uTexel.y) * gridScale;\n\n        // Neighbor samples\n        vec2 nE  = texture(uState, st + ddx).rg;\n        vec2 nW  = texture(uState, st - ddx).rg;\n        vec2 nN  = texture(uState, st + ddy).rg;\n        vec2 nS  = texture(uState, st - ddy).rg;\n        vec2 nNE = texture(uState, st + ddx + ddy).rg;\n        vec2 nNW = texture(uState, st - ddx + ddy).rg;\n        vec2 nSE = texture(uState, st + ddx - ddy).rg;\n        vec2 nSW = texture(uState, st - ddx - ddy).rg;\n\n        // Conservative divergence with inline face tensors\n        vec3 tE = flowTensor(st + ddx * 0.5);\n        vec3 tW = flowTensor(st - ddx * 0.5);\n        vec3 tN = flowTensor(st + ddy * 0.5);\n        vec3 tS = flowTensor(st - ddy * 0.5);\n\n        vec2 ab = vec2(a, b);\n\n        // Face fluxes\n        vec2 fx_E = tE.x * (nE - ab) + tE.z * (nN - nS + nNE - nSE) * 0.25;\n        vec2 fx_W = tW.x * (ab - nW) + tW.z * (nNW - nSW + nN - nS) * 0.25;\n        vec2 fy_N = tN.z * (nNE - nNW + nE - nW) * 0.25 + tN.y * (nN - ab);\n        vec2 fy_S = tS.z * (nE - nW + nSE - nSW) * 0.25 + tS.y * (ab - nS);\n\n        // Divergence\n        vec2 diff = (fx_E - fx_W) + (fy_N - fy_S);\n\n        // Thickness neighbor reads (shared for edge aniso + cone ring detection)\n        vec2 thNeighE = texture(uThick, vUV + vec2(uTexel.x, 0.0)).rg;\n        vec2 thNeighW = texture(uThick, vUV - vec2(uTexel.x, 0.0)).rg;\n        vec2 thNeighN = texture(uThick, vUV + vec2(0.0, uTexel.y)).rg;\n        vec2 thNeighS = texture(uThick, vUV - vec2(0.0, uTexel.y)).rg;\n\n        // Edge suppression: reduce isotropic diffusion + boost K at thin edges\n        float edgeAmt = 1.0 - smoothstep(uEdgeCut * 0.3, uEdgeCut, thick);\n        diff *= 1.0 - edgeAmt * 0.95;\n        K += edgeAmt * 0.1;\n\n        // Redirect suppressed diffusion radially to break up solid edge outline\n        vec2 thGrad = vec2(thNeighE.r - thNeighW.r, thNeighN.r - thNeighS.r) * 0.5 * thickScale;\n        float tGradLen = length(thGrad);\n        if (edgeAmt > 0.01 && tGradLen > 0.001) {\n            vec2 rd = thGrad / tGradLen;\n            // Directional 2nd derivative along radial (thickness gradient) direction\n            vec2 lapX = nE + nW - 2.0 * ab;\n            vec2 lapY = nN + nS - 2.0 * ab;\n            vec2 lapXY = (nNE - nNW - nSE + nSW) * 0.25;\n            vec2 radLap = lapX * rd.x*rd.x + lapY * rd.y*rd.y + 2.0 * lapXY * rd.x*rd.y;\n            float Da = mix(uDaMin, uDaMax, thick);\n            diff += edgeAmt * Da * 2.0 * radLap;\n        }\n\n        // Cone height gradient -> ring amount (reuse thickness neighbor reads)\n        float gradX = (thNeighE.g - thNeighW.g) * 0.5;\n        float gradY = (thNeighN.g - thNeighS.g) * 0.5;\n        float ringAmt = min(length(vec2(gradX, gradY)) * 8.0 / uConeEmit, 1.0);\n        float centerAmt = min(coneMap / uConeEmit, 1.0);\n\n        // Center: reduce diffusion + boost K\n        diff *= 1.0 - centerAmt * 0.8;\n        K += centerAmt * uConeDaBoost * 0.03;\n\n        // Ring: gentle Da boost + K boost\n        diff += ringAmt * uConeDaBoost * 0.1 * (nE + nW + nN + nS - 4.0 * ab);\n        K += ringAmt * uConeDaBoost * 0.02;\n\n        float abb = a * b * b;\n        float na = a + dt * (diff.x - abb + F * (1.0 - a));\n        float nb = b + dt * (uDbRatio * diff.y + abb - (F + K) * b);\n\n        // Flow advection: -vc pushes pattern along flow lines\n        // Uses constant time step (not RD grid-scaled dt) so strength is uniform\n        // Stronger in new areas (low b gradient), decays in established patterns\n        if (uAdvect > 0.0) {\n            vec2 flowVec = texture(uFlow, st).rg;\n            // Persistent noise-based swirl so patterns stay stirred when idle\n            float n1 = texture(uNoise, st * 4.0 + vec2(uTime * 0.015, 0.0)).r;\n            float n2 = texture(uNoise, st * 4.0 + vec2(0.0, uTime * 0.012)).r;\n            vec2 noiseFlow = vec2(n1, n2) * 0.15;\n            // Blend: real flow dominates when active, noise flow fills in when idle\n            float flowStr = length(flowVec);\n            float noiseMix = 1.0 - min(flowStr * 10.0, 1.0);\n            // Perturb flow direction with noise to break stripe alignment\n            float pertAngle = (n1 - 0.5) * 1.5;  // +/-0.75 radians (~43 degrees)\n            float cs = cos(pertAngle), sn = sin(pertAngle);\n            vec2 pertFlow = vec2(flowVec.x * cs - flowVec.y * sn,\n                                 flowVec.x * sn + flowVec.y * cs);\n            vec2 totalFlow = pertFlow + noiseFlow * noiseMix;\n\n            vec2 gradA = vec2(nE.r - nW.r, nN.r - nS.r) * 0.5;\n            vec2 gradB = vec2(nE.g - nW.g, nN.g - nS.g) * 0.5;\n            float bGradMag = length(gradB);\n            float patternAmt = smoothstep(0.0, 0.05, bGradMag);\n            float advStr = uAdvect * uSimSpeed * (1.0 - patternAmt * uAdvDecay);\n            na -= advStr * dot(totalFlow, gradA);\n            nb -= advStr * dot(totalFlow, gradB);\n        }\n\n        // Gentle center decay\n        float decayT = smoothstep(uScaleClamp, uScaleClamp + uDecayWidth, gridScale);\n        float decayRate = 0.02 * decayT * uSimSpeed;\n        na = mix(na, 1.0, decayRate);\n        nb = nb * (1.0 - decayRate);\n\n\n        // Seeding: continuous across all fluid areas\n        if (uSeedStr > 0.0) {\n            float coneMask = smoothstep(0.0, 0.01, thick);\n            float vacancy = smoothstep(0.20, 0.0, nb);\n            float seedNoise = texture(uNoise, st * uSeedScale).r;\n            float spatialMask = step(uSeedThr, seedNoise);\n            float seedAmt = uSeedStr * uSimSpeed * coneMask * vacancy * spatialMask;\n            na -= seedAmt;\n            nb += seedAmt;\n        }\n\n        fragColor = vec2(clamp(na, 0.0, 1.0), clamp(nb, 0.0, 1.0));\n    }",
                rdUpdateProg = linkProg(vertSrc, rdUpdateFragSrc),
                rdLocs = {
                    state: gl.getUniformLocation(rdUpdateProg, 'uState'),
                    thick: gl.getUniformLocation(rdUpdateProg, 'uThick'),
                    flow: gl.getUniformLocation(rdUpdateProg, 'uFlow'),
                    noise: gl.getUniformLocation(rdUpdateProg, 'uNoise'),
                    texel: gl.getUniformLocation(rdUpdateProg, 'uTexel'),
                    F: gl.getUniformLocation(rdUpdateProg, 'uF'),
                    K: gl.getUniformLocation(rdUpdateProg, 'uK'),
                    fCenter: gl.getUniformLocation(rdUpdateProg, 'uFCenter'),
                    kCenter: gl.getUniformLocation(rdUpdateProg, 'uKCenter'),
                    daMin: gl.getUniformLocation(rdUpdateProg, 'uDaMin'),
                    daMax: gl.getUniformLocation(rdUpdateProg, 'uDaMax'),
                    dbRatio: gl.getUniformLocation(rdUpdateProg, 'uDbRatio'),
                    aniso: gl.getUniformLocation(rdUpdateProg, 'uAniso'),
                    gridScale: gl.getUniformLocation(rdUpdateProg, 'uGridScale'),
                    scaleClamp: gl.getUniformLocation(rdUpdateProg, 'uScaleClamp'),
                    decayWidth: gl.getUniformLocation(rdUpdateProg, 'uDecayWidth'),
                    fNoise: gl.getUniformLocation(rdUpdateProg, 'uFNoise'),
                    kNoise: gl.getUniformLocation(rdUpdateProg, 'uKNoise'),
                    fkRamp: gl.getUniformLocation(rdUpdateProg, 'uFKRamp'),
                    coneDaBoost: gl.getUniformLocation(rdUpdateProg, 'uConeDaBoost'),
                    coneEmit: gl.getUniformLocation(rdUpdateProg, 'uConeEmit'),
                    edgeCut: gl.getUniformLocation(rdUpdateProg, 'uEdgeCut'),
                    swarmSpeed: gl.getUniformLocation(rdUpdateProg, 'uSwarmSpeed'),
                    seedStr: gl.getUniformLocation(rdUpdateProg, 'uSeedStr'),
                    seedThr: gl.getUniformLocation(rdUpdateProg, 'uSeedThr'),
                    seedSpd: gl.getUniformLocation(rdUpdateProg, 'uSeedSpd'),
                    coneSpeed: gl.getUniformLocation(rdUpdateProg, 'uConeSpeed'),
                    seedScale: gl.getUniformLocation(rdUpdateProg, 'uSeedScale'),
                    advect: gl.getUniformLocation(rdUpdateProg, 'uAdvect'),
                    advDecay: gl.getUniformLocation(rdUpdateProg, 'uAdvDecay'),
                    time: gl.getUniformLocation(rdUpdateProg, 'uTime'),
                    simSpeed: gl.getUniformLocation(rdUpdateProg, 'uSimSpeed'),
                    heartFKPulse: gl.getUniformLocation(rdUpdateProg, 'uHeartFKPulse'),
                    heartCenterRD: gl.getUniformLocation(rdUpdateProg, 'uHeartCenterRD'),
                    heartRadius: gl.getUniformLocation(rdUpdateProg, 'uHeartRadius'),
                    hoverPosRD: gl.getUniformLocation(rdUpdateProg, 'uHoverPosRD'),
                    hoverRDStr: gl.getUniformLocation(rdUpdateProg, 'uHoverRDStr'),
                },
                pcbGenFragSrc = `#version 300 es\n    precision highp float;\n    in vec2 vUV;\n    uniform vec2 uScrollOffset;\n    uniform float uVisHalf;\n    const float uSeed = 0.0;       // PCB seed (baked)\n    uniform float uFineDensity;\n    const float uHeightScale = 1.0; // height scale (baked)\n    uniform float uAspectYX;  // H/W for aspect-ratio corrected radial distances\n    uniform float uCorridorWidth;\n    uniform float uMazeSpacing;\n    uniform float uCorridorWobble;\n    // JS-authoritative cell data textures (eliminates hash mismatch)\n    uniform highp sampler2D uChipData;    // 2 texels/cell: (cx,cy,heX,heY),(mat,orientType,sizeCat,exists)\n    uniform highp sampler2D uCoarseData;  // 1 texel/cell: (cx,cy,radius,type)\n    uniform ivec2 uChipGridMin;           // (minGX, minGY) for texture coordinate mapping\n    uniform ivec2 uCoarseGridMin;\n    out vec4 fragOut;\n\n    // --- Hash functions ---\n    float hash21(vec2 p) {\n        p = fract(p * vec2(123.34, 456.21));\n        p += dot(p, p + 45.32);\n        return fract(p.x * p.y);\n    }\n    vec2 hash22(vec2 p) {\n        return vec2(hash21(p), hash21(p + vec2(37.158, 91.237)));\n    }\n\n    // --- Value noise for corridor wobble ---\n    float vnoise(vec2 p) {\n        vec2 i = floor(p);\n        vec2 f = fract(p);\n        f = f * f * (3.0 - 2.0 * f);\n        float a = hash21(i);\n        float b = hash21(i + vec2(1.0, 0.0));\n        float c = hash21(i + vec2(0.0, 1.0));\n        float d = hash21(i + vec2(1.0, 1.0));\n        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n    }\n\n    // --- Corridor maze evaluation ---\n    // Two sets of perpendicular wavy channels guarantee global connectivity.\n    // Returns 0.0 in wall regions, 1.0 in corridors.\n    float evalCorridors(vec2 worldUV, float seed) {\n        float spacing = uMazeSpacing;\n        float halfW = uCorridorWidth * 0.5;\n        float wobbleAmp = uCorridorWobble;\n\n        // Horizontal channels: spaced along Y, wobble in X\n        float hIdx = floor(worldUV.y / spacing);\n        float hCenter = (hIdx + 0.5) * spacing;\n        float hWobble = (vnoise(vec2(worldUV.x * 4.0, hIdx * 7.13 + seed * 3.1)) - 0.5) * wobbleAmp;\n        // Width variation along channel\n        float hWidthVar = 1.0 + 0.3 * (vnoise(vec2(worldUV.x * 6.0, hIdx * 5.3 + seed)) - 0.5);\n        float hDist = abs(worldUV.y - hCenter - hWobble);\n        float hCorridor = 1.0 - smoothstep(halfW * hWidthVar * 0.8, halfW * hWidthVar, hDist);\n\n        // Vertical channels: spaced along X, wobble in Y\n        float vIdx = floor(worldUV.x / spacing);\n        float vCenter = (vIdx + 0.5) * spacing;\n        float vWobble = (vnoise(vec2(vIdx * 9.37 + seed * 5.7, worldUV.y * 4.0)) - 0.5) * wobbleAmp;\n        float vWidthVar = 1.0 + 0.3 * (vnoise(vec2(vIdx * 4.7 + seed, worldUV.y * 6.0)) - 0.5);\n        float vDist = abs(worldUV.x - vCenter - vWobble);\n        float vCorridor = 1.0 - smoothstep(halfW * vWidthVar * 0.8, halfW * vWidthVar, vDist);\n\n        // Widen at intersections (both channels overlap)\n        float corridor = max(hCorridor, vCorridor);\n\n        return corridor;\n    }\n\n    // --- SDF primitives (2D) ---\n    float sdBox2(vec2 p, vec2 b) {\n        vec2 d = abs(p) - b;\n        return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    }\n    float sdRoundBox2(vec2 p, vec2 b, float r) {\n        return sdBox2(p, b) - r;\n    }\n\n    // --- Convex dimple height profile ---\n    // Quartic bump: peak * (1 - t^2)^2\n    float bumpProfile(float dist, float radius, float peak) {\n        float t = clamp(dist / radius, 0.0, 1.0);\n        float s = 1.0 - t * t;\n        return peak * s * s;\n    }\n\n    // --- Smooth sphere-cap profile ---\n    float sphereCapProfile(float dist, float radius, float peak) {\n        float t = clamp(dist / radius, 0.0, 1.0);\n        float t2 = t * t;\n        return peak * (1.0 - t2 * t2 * t2); // (1-t^6): flat top, steep edge rolloff\n    }\n\n    // --- Rounded box height profile ---\n    float boxProfile(float sdfDist, float rolloff, float peak) {\n        return peak * (1.0 - smoothstep(-rolloff, rolloff, sdfDist));\n    }\n\n    // --- Feature evaluation ---\n\n    // Convex dimple sets: 3-5 vertical columns of 3-wide bumps, evenly spaced\n    // Sparse grid (cell 0.35) so max ~2 sets visible vertically\n    void evalDimpleSets(vec2 worldUV, float seed, float density, float hScale,\n                        inout float height, inout float matID) {\n        float cellSize = 0.55;\n        vec2 cell = floor(worldUV / cellSize);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                vec2 c = cell + vec2(float(dx), float(dy));\n                if (hash21(c + seed * 7.31) > density) continue;\n\n                vec2 jitter = hash22(c + seed * 5.67) * 0.5 + 0.25;\n                vec2 setCenter = (c + jitter) * cellSize;\n                vec2 delta = worldUV - setCenter;\n\n                // How many columns in this set (3-4)\n                float nCols = 3.0 + floor(hash21(c * 2.3 + seed * 1.1) * 2.0);\n                // How many rows per column (9-17, always odd to avoid half-dot artifacts)\n                float nRows = 9.0 + 2.0 * floor(hash21(c * 3.7 + seed * 2.2) * 5.0);\n\n                float bumpSp = 0.016;  // spacing between bumps within a column\n                float colSp = 0.100;   // spacing between column centers\n\n                // Set bounding box (quick reject)\n                float setHalfW = colSp * (nCols - 1.0) * 0.5 + bumpSp * 1.5;\n                float setHalfH = bumpSp * (nRows - 1.0) * 0.5 + bumpSp * 1.5;\n                if (abs(delta.x) > setHalfW || abs(delta.y) > setHalfH) continue;\n                // Claim full footprint for overlap exclusion (same paint color as base)\n                if (matID < 0.5) matID = 1.0;\n\n                // Iterate columns\n                float colHalfSpan = colSp * (nCols - 1.0) * 0.5;\n                for (float ci = 0.0; ci < 5.0; ci += 1.0) {\n                    if (ci >= nCols) break;\n                    float colX = -colHalfSpan + ci * colSp;\n\n                    // Within this column: 3 bumps wide, nRows tall\n                    vec2 colDelta = vec2(delta.x - colX, delta.y);\n                    vec2 colHE = vec2(bumpSp * 1.0, bumpSp * (nRows - 1.0) * 0.5);\n                    float bumpR = 0.0055;\n                    if (abs(colDelta.x) < colHE.x + bumpR &&\n                        abs(colDelta.y) < colHE.y + bumpR) {\n                        vec2 snapped = clamp(round(colDelta / bumpSp) * bumpSp,\n                                            -colHE, colHE);\n                        float dist = length(colDelta - snapped);\n                        float bumph = bumpProfile(dist, bumpR, 0.020 * hScale);\n                        if (bumph > height) {\n                            height = bumph;\n                            matID = 1.0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Helper: stamp a single concave dimple at world position\n    void stampPit(vec2 worldUV, vec2 pos, float hScale,\n                  inout float height, inout float matID) {\n        float dist = length(worldUV - pos);\n        float pit = bumpProfile(dist, 0.0036, 0.010 * hScale);\n        if (pit > 0.001 * hScale) {\n            float newH = -pit;\n            if (newH < height || matID < 0.5) {\n                height = min(height, newH);\n                matID = 2.0;\n            }\n        }\n    }\n\n    // Concave dimples: three pattern types on a medium grid\n    //  A) Diagonal staircase  3 columns, each offset vertically (slanted)\n    //  B) Scattered random  loose individual dimples\n    //  C) Compact rectangles  3x2 or 4x2 blocks, occasionally +1 extra\n    void evalConcaveDimples(vec2 worldUV, float seed, float density, float hScale,\n                            inout float height, inout float matID) {\n        float cellSize = 0.22;\n        vec2 cell = floor(worldUV / cellSize);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                vec2 c = cell + vec2(float(dx), float(dy));\n                if (hash21(c + seed * 14.73 + 700.0) > density) continue;\n\n                float typeH = hash21(c * 1.9 + seed * 5.31 + 800.0);\n                vec2 jitter = hash22(c + seed * 6.82 + 900.0) * 0.5 + 0.25;\n                vec2 center = (c + jitter) * cellSize;\n                vec2 delta = worldUV - center;\n\n                float sp = 0.012; // dimple spacing (2x scaled)\n\n                if (typeH < 0.40) {\n                    // A) Diagonal staircase: 3 columns, tall, each shifted down\n                    float nRows = 6.0 + floor(hash21(c * 3.1 + seed * 2.4) * 8.0);\n                    float diagShift = sp * 0.8; // gentle diagonal offset per column\n                    // Bounding box\n                    float halfW = sp * 1.0 + sp;\n                    float halfH = sp * (nRows - 1.0) * 0.5 + diagShift + sp;\n                    if (abs(delta.x) < halfW && abs(delta.y) < halfH) {\n                        for (float col = -1.0; col <= 1.0; col += 1.0) {\n                            float colYOff = col * diagShift;\n                            float colHalfH = sp * (nRows - 1.0) * 0.5;\n                            vec2 colD = vec2(delta.x - col * sp, delta.y - colYOff);\n                            if (abs(colD.y) < colHalfH + sp) {\n                                float snY = clamp(round(colD.y / sp) * sp,\n                                                  -colHalfH, colHalfH);\n                                stampPit(worldUV, center + vec2(col * sp, colYOff + snY),\n                                         hScale, height, matID);\n                            }\n                        }\n                    }\n                } else if (typeH < 0.65) {\n                    // B) Scattered random: 6-14 loose dimples\n                    float nDots = 6.0 + floor(hash21(c * 2.8 + seed * 1.3) * 9.0);\n                    float scatter = cellSize * 0.40;\n                    if (abs(delta.x) < scatter + sp && abs(delta.y) < scatter + sp) {\n                        for (float i = 0.0; i < 14.0; i += 1.0) {\n                            if (i >= nDots) break;\n                            vec2 off = (hash22(c * (3.0 + i) + seed * (i + 1.0) + 1000.0)\n                                       - 0.5) * scatter * 2.0;\n                            stampPit(worldUV, center + off, hScale, height, matID);\n                        }\n                    }\n                } else {\n                    // C) Compact rectangles: 3x2 or 4x2, occasionally +1 extra\n                    float nCols = (hash21(c * 4.2 + seed * 3.7) > 0.5) ? 4.0 : 3.0;\n                    float nRows = 2.0;\n                    bool extraDot = (nCols > 3.5) &&\n                                    (hash21(c * 5.5 + seed * 4.1) > 0.5);\n                    float halfW = sp * (nCols - 1.0) * 0.5;\n                    float halfH = sp * 0.5;\n                    if (abs(delta.x) < halfW + sp * 2.0 && abs(delta.y) < halfH + sp) {\n                        for (float iy = 0.0; iy < 2.0; iy += 1.0) {\n                            for (float ix = 0.0; ix < 4.0; ix += 1.0) {\n                                if (ix >= nCols) break;\n                                vec2 pos = center + vec2(\n                                    (ix - (nCols - 1.0) * 0.5) * sp,\n                                    (iy - 0.5) * sp);\n                                stampPit(worldUV, pos, hScale, height, matID);\n                            }\n                        }\n                        // Extra dimple off one end\n                        if (extraDot) {\n                            vec2 pos = center + vec2(halfW + sp, 0.0);\n                            stampPit(worldUV, pos, hScale, height, matID);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Piano-key pin arrays: indented slots (white keys) + raised bent pins (black keys)\n    // Two-part structure: rectangular pits in the surface, with flat pins extending\n    // to one side that cast harsh shadows. Occasional gaps reinforce the piano look.\n    void evalPinGrid(vec2 worldUV, float seed, float hScale,\n                     inout float height, inout float matID) {\n        float cellSize = 0.50;\n        vec2 cell = floor(worldUV / cellSize);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                vec2 c = cell + vec2(float(dx), float(dy));\n                // ~20% of cells have a pin array\n                if (hash21(c + seed * 13.17 + 500.0) > 0.20) continue;\n\n                vec2 jitter = hash22(c + seed * 9.43 + 600.0) * 0.6 + 0.2;\n                vec2 featureCenter = (c + jitter) * cellSize;\n                vec2 delta = worldUV - featureCenter;\n\n                // Array orientation: vertical or horizontal\n                float rotHash = hash21(c * 4.1 + seed * 7.3 + 800.0);\n                bool rotated = rotHash > 0.5;\n                vec2 localD = rotated ? vec2(delta.y, delta.x) : delta;\n\n                // Bent pins always extend to the left so white keys are to the right\n                // (light from left casts shadows right, matching piano key look)\n                float pinDir = -1.0;\n\n                float pinSpacing = 0.016;\n                float nPins = 20.0 + floor(hash21(c * 2.7 + seed * 3.8) * 20.0);\n                float rowExtent = pinSpacing * (nPins - 1.0) * 0.5;\n\n                // Wider bounding box to account for offset raised pins\n                if (abs(localD.x) < 0.050 && abs(localD.y) < rowExtent + pinSpacing) {\n                    float snappedY = round(localD.y / pinSpacing) * pinSpacing;\n                    if (abs(snappedY) > rowExtent + 0.001) continue;\n                    vec2 pinP = vec2(localD.x, localD.y - snappedY);\n\n                    // --- White key: indent at EVERY position ---\n                    // Same shape as original pins, flipped below surface\n                    float indentDist = sdRoundBox2(pinP, vec2(0.018, 0.003), 0.001);\n                    float indentH = boxProfile(indentDist, 0.003, -0.010 * hScale);\n                    if (indentH < -0.001 && indentH < height) {\n                        height = indentH;\n                        matID = 3.0;\n                    }\n\n                    // --- Black key: raised bent pin overlapping white key ---\n                    // Sits on top of the white key (like real piano black keys)\n                    // Offset just enough to let white key peek out on one side\n                    float pinIdx = (snappedY + rowExtent) / pinSpacing;\n                    float pinHash = hash21(vec2(pinIdx, 0.0) + c * 3.3 + seed * 6.1);\n                    // ~65% of positions have a raised pin; gaps reinforce piano look\n                    if (pinHash > 0.35) {\n                        vec2 pinOffset = vec2(pinDir * 0.008, 0.0);\n                        vec2 pinP2 = pinP - pinOffset;\n                        float raisedDist = sdRoundBox2(pinP2, vec2(0.010, 0.0015), 0.0005);\n                        float raisedH = boxProfile(raisedDist, 0.002, 0.030 * hScale);\n                        if (raisedH > 0.001 && raisedH > height) {\n                            height = raisedH;\n                            matID = 3.0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Helper: stamp a single chip (painted or dark) at given position\n    // orientType: 0=normal (heX/heY pre-swapped by JS if needed), 1=diamond (45 in pixel space)\n    void stampChip(vec2 worldUV, vec2 pos, vec2 halfExt, float rnd,\n                   float rolloff, float peak, float hScale, float mat,\n                   float orientType,\n                   inout float height, inout float matID) {\n        vec2 delta = worldUV - pos;\n        vec2 rd, he;\n        if (orientType > 0.5) {\n            // Diamond: aspect-correct, rotate 45\n            float s707 = 0.7071068;\n            vec2 ad = delta * vec2(1.0, uAspectYX);\n            rd = vec2(s707 * (ad.x + ad.y), s707 * (ad.y - ad.x));\n            he = halfExt;\n        } else {\n            // Aspect-correct so rounding and circles are uniform in pixel space\n            rd = delta * vec2(1.0, uAspectYX);\n            he = halfExt * vec2(1.0, uAspectYX);\n        }\n        float d = sdRoundBox2(rd, he, rnd);\n        float h = boxProfile(d, rolloff, peak * hScale);\n        // Don't overlap other chips/capacitors (matID 5,6,7)\n        if (matID > 4.5) h = 0.0;\n\n        // IC package detail on dark chips: pin-1 dot or orientation notch\n        if (mat > 6.5 && h > 0.001 && min(he.x, he.y) > 0.008) {\n            float fHash = hash21(pos * 137.0 + 42.0);\n            if (fHash < 0.20) {\n                // Shallow circular indent (pin-1 marker) near one corner\n                float cHash = hash21(pos * 91.0 + 73.0);\n                vec2 cs = vec2(cHash < 0.5 ? -1.0 : 1.0,\n                               fract(cHash * 7.0) < 0.5 ? -1.0 : 1.0);\n                vec2 dotPos = cs * he * 0.50;\n                float minHe = min(he.x, he.y);\n                float dotR = minHe * mix(0.35, 0.50, smoothstep(0.008, 0.035, minHe));\n                float dotD = length(rd - dotPos);\n                h -= bumpProfile(dotD, dotR, peak * hScale * 0.075);\n            } else if (fHash < 0.50) {\n                // Semicircular notch centered on one short edge\n                float eHash = hash21(pos * 53.0 + 17.0);\n                vec2 nc; float nr;\n                if (he.x < he.y) {\n                    nc = vec2((eHash < 0.5 ? -1.0 : 1.0) * he.x, 0.0);\n                    nr = he.x * 0.40;\n                } else {\n                    nc = vec2(0.0, (eHash < 0.5 ? -1.0 : 1.0) * he.y);\n                    nr = he.y * 0.40;\n                }\n                h -= bumpProfile(length(rd - nc), nr, peak * hScale * 0.25);\n            }\n        }\n\n        if (h > height) { height = h; matID = mat; }\n    }\n\n    // Coarse grid features: paint drops and capacitors\n    // Reads pre-computed cell data from JS-authoritative texture\n    void evalCoarseFeatures(vec2 worldUV, float hScale,\n                            inout float height, inout float matID) {\n        float cellSize = 0.22;\n        ivec2 cell = ivec2(floor(worldUV / cellSize));\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                ivec2 c = cell + ivec2(dx, dy);\n                int lx = c.x - uCoarseGridMin.x;\n                int ly = c.y - uCoarseGridMin.y;\n                if (lx < 0 || ly < 0 || lx >= ${COARSE_DATA_W} || ly >= ${COARSE_DATA_H}) continue;\n\n                vec4 data = texelFetch(uCoarseData, ivec2(lx, ly), 0);\n                float ftype = data.w;\n                if (ftype < 0.5) continue;\n\n                vec2 featureCenter = data.xy;\n                float radius = data.z;\n                vec2 delta = worldUV - featureCenter;\n\n                if (ftype > 3.5 && ftype < 4.5) {\n                    // Paint drop\n                    float dist = length(delta * vec2(1.0, uAspectYX));\n                    float dropH = sphereCapProfile(dist, radius, 0.024 * hScale);\n                    if (dropH > height) { height = dropH; matID = ftype; }\n                } else if (ftype > 4.5) {\n                    // Capacitor\n                    float capDist = length(delta * vec2(1.0, uAspectYX)) - radius;\n                    float capH = boxProfile(capDist, 0.002, 0.065 * hScale);\n                    if (matID > 4.5) capH = 0.0;\n                    if (capH > height) { height = capH; matID = 5.0; }\n                }\n            }\n        }\n    }\n\n    // Maze chip grid: reads pre-computed cell data from JS-authoritative texture\n    void evalMazeChips(vec2 worldUV, float hScale,\n                       inout float height, inout float matID) {\n        float cellSize = 0.08;\n        ivec2 cell = ivec2(floor(worldUV / cellSize));\n\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                ivec2 c = cell + ivec2(dx, dy);\n                int lx = (c.x - uChipGridMin.x) * 2;\n                int ly = c.y - uChipGridMin.y;\n                if (lx < 0 || ly < 0 || lx >= ${CHIP_DATA_W} - 1 || ly >= ${CHIP_DATA_H}) continue;\n\n                vec4 posData = texelFetch(uChipData, ivec2(lx, ly), 0);\n                vec4 matData = texelFetch(uChipData, ivec2(lx + 1, ly), 0);\n                if (matData.a < 0.5) continue; // cell doesn't exist\n\n                vec2 chipPos = posData.xy;\n                vec2 he = posData.zw;\n                float mat = matData.x;\n                float orientType = matData.y;\n                float sizeCat = matData.z;\n\n                // Early distance check\n                float maxR = cellSize * 0.75;\n                if (length(worldUV - chipPos) > maxR) continue;\n\n                // Decode size category  round, rolloff, peak\n                float rnd, rolloff, peak;\n                if (sizeCat < 0.5) {\n                    rnd = 0.002; rolloff = 0.002; peak = 0.025;\n                } else if (sizeCat < 1.5) {\n                    rnd = 0.003; rolloff = 0.003; peak = 0.035;\n                } else if (sizeCat < 2.5) {\n                    rnd = 0.003; rolloff = 0.004; peak = 0.042;\n                } else {\n                    rnd = 0.004; rolloff = 0.004; peak = 0.050;\n                }\n\n                stampChip(worldUV, chipPos, he, rnd, rolloff, peak, hScale, mat,\n                          orientType, height, matID);\n            }\n        }\n    }\n\n    // Scattered individual dimples on a fine grid to break up bare areas\n    void evalScatterPits(vec2 worldUV, float seed, float density, float hScale,\n                         inout float height, inout float matID) {\n        float cellSize = 0.10;\n        vec2 cell = floor(worldUV / cellSize);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                vec2 c = cell + vec2(float(dx), float(dy));\n                float h0 = hash21(c + seed * 11.37 + 1200.0);\n                if (h0 > density) continue;\n                vec2 jitter = hash22(c + seed * 8.19 + 1300.0) * 0.7 + 0.15;\n                vec2 pos = (c + jitter) * cellSize;\n                float dist = length(worldUV - pos);\n                // Mix of convex bumps and concave pits\n                float typeH = hash21(c * 3.3 + seed * 4.7 + 1400.0);\n                float r = 0.002 + hash21(c * 2.1 + seed * 6.3 + 1500.0) * 0.002;\n                float pk = 0.008 + hash21(c * 1.7 + seed * 5.1 + 1600.0) * 0.012;\n                float h = bumpProfile(dist, r, pk * hScale);\n                if (h > 0.001 * hScale) {\n                    if (typeH < 0.95) {\n                        // Concave pit\n                        if (-h < height || matID < 0.5) {\n                            height = min(height, -h);\n                            matID = 2.0;\n                        }\n                    } else {\n                        // Convex bump\n                        if (h > height) {\n                            height = h;\n                            matID = 1.0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    const float PCB_MARGIN = 0.15; // 15% extra on each side for shadow rays\n    void main() {\n        // Map screen pixel to world UV with margin for shadow overshoot\n        vec2 worldUV = (vUV * (1.0 + 2.0 * PCB_MARGIN) - PCB_MARGIN) * 0.5 + uScrollOffset;\n\n        float height = 0.0;\n        float matID = 0.0;\n\n        // Corridor mask for this fragment (smooth edges for visual output)\n        float corridorMask = evalCorridors(worldUV, uSeed);\n\n        // Maze chips: reads JS-authoritative cell data texture\n        evalMazeChips(worldUV, uHeightScale, height, matID);\n\n        // Coarse features: reads JS-authoritative cell data texture\n        evalCoarseFeatures(worldUV, uHeightScale, height, matID);\n\n        // Skip small features where coarse features already claim space\n        bool occupied = matID > 4.5; // capacitors(5), chips(6,7)\n\n        // Convex dimple sets: only in open corridor areas\n        if (!occupied && corridorMask > 0.5)\n            evalDimpleSets(worldUV, uSeed, uFineDensity, uHeightScale, height, matID);\n\n        // Pin arrays: only in open corridor areas, blocked by chips/capacitors/paint\n        if (!occupied && matID < 3.5 && corridorMask > 0.5)\n            evalPinGrid(worldUV, uSeed, uHeightScale, height, matID);\n\n        // Concave dimples only on bare PCB (matID=0)\n        if (matID < 0.5)\n            evalConcaveDimples(worldUV, uSeed, uFineDensity, uHeightScale, height, matID);\n\n        // Scattered individual pits/bumps on remaining bare areas (sparse)\n        if (matID < 0.5)\n            evalScatterPits(worldUV, uSeed, 0.15, uHeightScale, height, matID);\n\n        fragOut = vec4(height, matID, corridorMask, 1.0);\n    }`,
                pcbGenProg = linkProg(vertSrc, pcbGenFragSrc),
                pcbGenLocs = {
                    scrollOffset: gl.getUniformLocation(pcbGenProg, 'uScrollOffset'),
                    visHalf: gl.getUniformLocation(pcbGenProg, 'uVisHalf'),
                    fineDensity: gl.getUniformLocation(pcbGenProg, 'uFineDensity'),
                    aspectYX: gl.getUniformLocation(pcbGenProg, 'uAspectYX'),
                    corridorWidth: gl.getUniformLocation(pcbGenProg, 'uCorridorWidth'),
                    mazeSpacing: gl.getUniformLocation(pcbGenProg, 'uMazeSpacing'),
                    corridorWobble: gl.getUniformLocation(pcbGenProg, 'uCorridorWobble'),
                    chipData: gl.getUniformLocation(pcbGenProg, 'uChipData'),
                    coarseData: gl.getUniformLocation(pcbGenProg, 'uCoarseData'),
                    chipGridMin: gl.getUniformLocation(pcbGenProg, 'uChipGridMin'),
                    coarseGridMin: gl.getUniformLocation(pcbGenProg, 'uCoarseGridMin'),
                },
                obsGenFragSrc = `#version 300 es\n    precision highp float;\n    in vec2 vUV;\n    uniform vec2 uScrollOffset;\n    uniform float uAspectYX;\n    // JS-authoritative cell data textures\n    uniform highp sampler2D uChipData;\n    uniform highp sampler2D uCoarseData;\n    uniform ivec2 uChipGridMin;\n    uniform ivec2 uCoarseGridMin;\n    out vec4 fragOut;  // only RG used (RG16F framebuffer)\n\n    // SDF primitives (same as PCB gen shader)\n    float sdBox2(vec2 p, vec2 b) {\n        vec2 d = abs(p) - b;\n        return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    }\n    float sdRoundBox2(vec2 p, vec2 b, float r) {\n        return sdBox2(p, b) - r;\n    }\n    float boxProfile(float sdfDist, float rolloff, float peak) {\n        return peak * (1.0 - smoothstep(-rolloff, rolloff, sdfDist));\n    }\n    float sphereCapProfile(float dist, float radius, float peak) {\n        float t = clamp(dist / radius, 0.0, 1.0);\n        float t2 = t * t;\n        return peak * (1.0 - t2 * t2 * t2);\n    }\n\n    void main() {\n        // Convert field UV [0,1] to world UV\n        // fieldUV = worldUV (mod 1 due to REPEAT). Unwrap using scroll as anchor.\n        // The visible center is at fieldUV = fract(scroll + 0.25), worldUV = scroll + 0.25\n        vec2 fieldCenter = uScrollOffset + 0.25;\n        vec2 diff = vUV - fract(fieldCenter);\n        diff -= round(diff);  // wrap to [-0.5, 0.5]\n        vec2 worldUV = fieldCenter + diff;\n\n        float maxHeight = 0.0;\n        float maxMatID = 0.0;\n\n        // --- Maze chips (only matID >= 4: painted=6, dark=7) ---\n        float chipCell = 0.08;\n        ivec2 cell = ivec2(floor(worldUV / chipCell));\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                ivec2 c = cell + ivec2(dx, dy);\n                int lx = (c.x - uChipGridMin.x) * 2;\n                int ly = c.y - uChipGridMin.y;\n                if (lx < 0 || ly < 0 || lx >= ${CHIP_DATA_W} - 1 || ly >= ${CHIP_DATA_H}) continue;\n\n                vec4 posData = texelFetch(uChipData, ivec2(lx, ly), 0);\n                vec4 matData = texelFetch(uChipData, ivec2(lx + 1, ly), 0);\n                if (matData.a < 0.5) continue;\n\n                float mat = matData.x;\n                if (mat < 3.5) continue; // skip dimples/pins (matID 1-3)\n\n                vec2 chipPos = posData.xy;\n                vec2 he = posData.zw;\n                float orientType = matData.y;\n                float sizeCat = matData.z;\n\n                float maxR = chipCell * 0.75;\n                if (length(worldUV - chipPos) > maxR) continue;\n\n                float rnd, rolloff, peak;\n                if (sizeCat < 0.5) { rnd = 0.002; rolloff = 0.002; peak = 0.025; }\n                else if (sizeCat < 1.5) { rnd = 0.003; rolloff = 0.003; peak = 0.035; }\n                else if (sizeCat < 2.5) { rnd = 0.003; rolloff = 0.004; peak = 0.042; }\n                else { rnd = 0.004; rolloff = 0.004; peak = 0.050; }\n\n                vec2 delta = worldUV - chipPos;\n                vec2 rd;\n                if (orientType > 0.5) {\n                    float s707 = 0.7071068;\n                    vec2 ad = delta * vec2(1.0, uAspectYX);\n                    rd = vec2(s707 * (ad.x + ad.y), s707 * (ad.y - ad.x));\n                } else {\n                    rd = delta;\n                }\n                float d = sdRoundBox2(rd, he, rnd);\n                float h = boxProfile(d, rolloff, peak);\n                if (h > maxHeight) { maxHeight = h; maxMatID = mat; }\n            }\n        }\n\n        // --- Coarse features (paint drops matID=4, capacitors matID=5) ---\n        float coarseCell = 0.22;\n        ivec2 ccell = ivec2(floor(worldUV / coarseCell));\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                ivec2 c = ccell + ivec2(dx, dy);\n                int lx = c.x - uCoarseGridMin.x;\n                int ly = c.y - uCoarseGridMin.y;\n                if (lx < 0 || ly < 0 || lx >= ${COARSE_DATA_W} || ly >= ${COARSE_DATA_H}) continue;\n\n                vec4 data = texelFetch(uCoarseData, ivec2(lx, ly), 0);\n                float ftype = data.w;\n                if (ftype < 3.5) continue; // skip non-obstacle types\n\n                vec2 featureCenter = data.xy;\n                float radius = data.z;\n                vec2 delta = worldUV - featureCenter;\n\n                if (ftype > 3.5 && ftype < 4.5) {\n                    // Paint drop\n                    float dist = length(delta * vec2(1.0, uAspectYX));\n                    float dropH = sphereCapProfile(dist, radius, 0.024);\n                    if (dropH > maxHeight) { maxHeight = dropH; maxMatID = 4.0; }\n                } else if (ftype > 4.5) {\n                    // Capacitor\n                    float capDist = length(delta * vec2(1.0, uAspectYX)) - radius;\n                    float capH = boxProfile(capDist, 0.002, 0.065);\n                    if (capH > maxHeight) { maxHeight = capH; maxMatID = 5.0; }\n                }\n            }\n        }\n\n        fragOut = vec4(maxHeight, maxMatID, 0.0, 1.0);\n    }`,
                obsGenProg = linkProg(vertSrc, obsGenFragSrc),
                obsGenLocs = {
                    scrollOffset: gl.getUniformLocation(obsGenProg, 'uScrollOffset'),
                    aspectYX: gl.getUniformLocation(obsGenProg, 'uAspectYX'),
                    chipData: gl.getUniformLocation(obsGenProg, 'uChipData'),
                    coarseData: gl.getUniformLocation(obsGenProg, 'uCoarseData'),
                    chipGridMin: gl.getUniformLocation(obsGenProg, 'uChipGridMin'),
                    coarseGridMin: gl.getUniformLocation(obsGenProg, 'uCoarseGridMin'),
                },
                dispFragSrc =
                    "#version 300 es\n    precision highp float;\n    in vec2 vUV;\n    uniform sampler2D uFlow;\n    uniform sampler2D uThick;\n    uniform sampler2D uPcb;       // PCB height map (R=height, G=matID)\n    uniform sampler2D uRDState;   // RD state (R=a, G=b)\n    uniform vec2 uScrollOffset;\n    uniform vec2 uTexel;          // 1/W, 1/H (screen/field texel)\n    uniform vec2 uPcbTexel;      // 1/PCB_W, 1/PCB_H (PCB texture texel)\n    const float uNormalScale = 60.0;      // normal bump intensity (baked)\n    const float uPcbBright = 1.0;         // PCB brightness (baked)\n    const float uGreenScale = 0.2;        // green tint scale (baked)\n    const float uRustDensity = 0.0;       // rust density (baked)\n    const float uRustSpotScale = 0.2;     // rust spot scale (baked)\n    const float uRustDensityScale = 0.5;  // rust density scale (baked)\n    const float uRustDetail = 0.25;       // rust detail (baked)\n    uniform int uConeCount;\n    uniform vec2 uConePos[15];\n    uniform float uConeSquash[15];\n    uniform vec2 uConeSquashDir[15];\n    uniform float uConeRadius;\n    uniform float uAspectYX;     // H/W for circular cone rendering\n    uniform float uFluidRim;     // rim light strength\n    uniform float uFluidRimPow;  // rim tightness exponent\n    uniform float uNrmStr;       // normal amplification\n    uniform float uAmbient;      // ambient light floor\n    uniform float uFluidRough;   // surface roughness\n    uniform float uFluidF0;      // Fresnel F0\n    uniform float uCamPitch;     // camera pitch in radians (0 = top-down, 1.4 = near horizontal)\n    uniform float uTime;         // elapsed time for color cycling\n    uniform int uShadowSteps;    // dynamic shadow ray step count\n    uniform float uHeartPulse;\n    uniform vec3 uTapRings[4];\n    uniform float uTapRingSpeed;\n    uniform float uTapRingLife;\n\n    uniform float uVisScale;\n    uniform vec2 uHoverGround;\n    uniform float uHoverGlow;\n    // RD display parameters (baked)\n    const float uRDThLo = 0.050;\n    const float uRDThHi = 0.445;\n    const float uRDThCLo = 0.050;\n    const float uRDThCHi = 0.445;\n    const float uRDGammaEdge = 0.60;\n    const float uRDGammaCenter = 0.60;\n    const float uRDSharpen = 1.00;\n    const float uRDEdgeCut = 0.33;\n    const float uRDRingStr = 0.85;\n    const float uRDRingWidth = 9.00;\n    const float uRDRingThick = 0.35;\n    out vec4 fragColor;\n\n    const float PI = 3.14159265;\n\n    // --- Noise (ported from pcb-surface-test.html) ---\n    float hash(vec2 p) {\n        vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n        p3 += dot(p3, p3.yzx + 33.33);\n        return fract((p3.x + p3.y) * p3.z);\n    }\n\n    float vnoise(vec2 p) {\n        vec2 i = floor(p), f = fract(p);\n        f = f * f * (3.0 - 2.0 * f);\n        float a = hash(i), b = hash(i + vec2(1,0));\n        float c = hash(i + vec2(0,1)), d = hash(i + vec2(1,1));\n        return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);\n    }\n\n    float fbm(vec2 p) {\n        float v = 0.0, a = 0.5;\n        for (int i = 0; i < 5; i++) {\n            v += a * vnoise(p);\n            p = p * 2.0 + vec2(100.0);\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // --- GGX clear-coat PBR (ported from pcb-surface-test.html) ---\n    float ggxD(float NdotH, float a2) {\n        float denom = NdotH * NdotH * (a2 - 1.0) + 1.0;\n        return a2 / (PI * denom * denom);\n    }\n    float ggxG1(float NdotX, float k) {\n        return NdotX / (NdotX * (1.0 - k) + k);\n    }\n    float ggxG(float NdotV, float NdotL, float roughness) {\n        float r = roughness + 1.0;\n        float k = r * r / 8.0;\n        return ggxG1(NdotV, k) * ggxG1(NdotL, k);\n    }\n    float fresnelSchlick(float cosTheta, float F0) {\n        return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n    }\n\n    // --- Procedural PCB paint color ---\n    vec3 paintColor(vec2 p) {\n        vec3 col = vec3(0.85, 0.62, 0.05);\n        float gs = uGreenScale;\n        float sw1 = fbm(p * 18.0 * gs + vec2(3.7, 1.2));\n        float sw2 = fbm(vec2(p.x * 28.0 * gs, p.y * 10.0 * gs) + vec2(-5.3, 8.1));\n        float swirl = sw1 * 0.6 + sw2 * 0.4;\n        float greenAmt = smoothstep(0.44, 0.64, swirl) * 0.25;\n        col = mix(col, vec3(0.30, 0.52, 0.10), greenAmt);\n        float orangeAmt = smoothstep(0.30, 0.15, swirl) * 0.20;\n        // Layer 1: Rust spot shapes (spot scale slider controls frequency)\n        float rustSpots = vnoise(p * 32.0 * uRustSpotScale + vec2(5.5, -3.2));\n        float spotShape = smoothstep(0.80, 0.62, rustSpots);\n        // Layer 2: Placement mask (density slider = threshold, density scale = frequency)\n        float placeNoise = vnoise(p * 10.0 * uRustDensityScale + vec2(-8.2, 3.7));\n        float placeThresh = 0.75 - uRustDensity * 0.35;\n        float placeMask = smoothstep(placeThresh, placeThresh + 0.15, placeNoise);\n        float rustAmt = spotShape * placeMask;\n        orangeAmt += rustAmt * 0.25;\n        // Layer 3: Fine detail  darkens within rust spots for texture variation\n        // Two sub-layers at different scales to avoid uniform distribution\n        float fine1 = vnoise(p * 85.0 + vec2(11.3, -5.7));\n        float fine2 = vnoise(p * 48.0 + vec2(-3.1, 9.4));\n        float fineMask = fine1 * 0.55 + fine2 * 0.45;\n        float detailDarken = smoothstep(0.35, 0.7, fineMask) * 0.25 * uRustDetail;\n        orangeAmt += rustAmt * detailDarken;\n        col = mix(col, vec3(0.65, 0.30, 0.04), orangeAmt);\n        float thick = fbm(p * 28.0 + vec2(-1.3, 4.7));\n        col *= 0.88 + 0.24 * thick;\n        col *= 0.97 + 0.06 * hash(floor(p * 500.0));\n        return col;\n    }\n\n    // --- Heightfield shadow ray ---\n    // Marches toward light in screen UV, checking if taller features block the ray.\n    // Uses Quilez-style soft shadow: min(k * gap / distance) for penumbra.\n    // skipMat >= 0: ignore texels with that material ID (for paint drop self-shadow bypass)\n    float shadowRay(vec2 uv, float h, float skipMat) {\n        vec2 lightSurf = vec2(0.4, 0.35);\n        float lightUp = 1.0;\n        float tanElev = lightUp / length(lightSurf);\n\n        vec2 baseStepDir = normalize(lightSurf / uPcbTexel) * uPcbTexel * 2.0;\n        float stepScale = 24.0 / float(uShadowSteps); // larger steps when fewer steps\n        vec2 stepDir = baseStepDir * stepScale;\n        float worldStep = length(stepDir) * 0.5;\n        float hPerStep = tanElev * worldStep;\n\n        float res = 1.0;\n        float rayH = max(h, 0.0); // indents start at ground level, not below\n        vec2 pos = uv;\n        float k = 2.0;  // low k = wide soft penumbra\n\n        for (int i = 1; i <= 24; i++) {\n            if (i > uShadowSteps) break;\n            pos += stepDir;\n            rayH += hPerStep;\n            vec4 s = texture(uPcb, pos);\n            float sH = s.r;\n            // Skip texels matching skipMat (e.g. paint drop ignoring own dome)\n            if (skipMat >= 0.0 && abs(s.g - skipMat) < 0.5) sH = 0.0;\n            // All raised features cast shadows (dimples, pins, chips)\n            sH = sH > 0.003 ? sH : 0.0;\n            float gap = rayH - sH;\n            if (gap < 0.0) return 0.0;\n            res = min(res, k * gap / (worldStep * float(i)));\n        }\n        return clamp(res, 0.0, 1.0);\n    }\n\n    const float PCB_MARGIN = 0.15;\n    void main() {\n        // --- Perspective camera ---\n        // Camera orbits around swarm center, pitch=0 is top-down, increasing = lower angle\n        float pitch = uCamPitch;\n        float camDist = 1.0;\n        vec3 camPos = vec3(0.5, camDist * cos(pitch), 0.5 - camDist * sin(pitch));\n        vec3 camTgt = vec3(0.5, 0.0, 0.5);\n        vec3 fwd = normalize(camTgt - camPos);\n        // Camera basis: right is always +X, up blends from +Z toward +Y with pitch\n        vec3 cRight = normalize(cross(fwd, vec3(0.0, 0.0, -1.0)));\n        vec3 cUp = cross(fwd, cRight);\n\n        // Cast ray through this pixel\n        vec2 ndc = vUV - 0.5;\n        vec3 rayDir = normalize(fwd + ndc.x * cRight + ndc.y * cUp);\n\n        // Intersect ground plane Y=0\n        if (rayDir.y >= -0.001) {\n            // Ray misses ground (above horizon)\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n        float t = -camPos.y / rayDir.y;\n        vec3 hit = camPos + t * rayDir;\n        vec2 groundUV = vec2(hit.x, hit.z);\n        // View direction: surface point toward camera\n        vec3 V = normalize(camPos - hit);\n\n        vec2 fieldUV = groundUV * uVisScale + uScrollOffset;\n\n        // --- PCB height and normal ---\n        // PCB texture has margin; map screen UV to center portion\n        vec2 pcbOffset = fieldUV - uScrollOffset;\n        pcbOffset -= round(pcbOffset);\n        vec2 pcbUV = (pcbOffset * 2.0 + PCB_MARGIN) / (1.0 + 2.0 * PCB_MARGIN);\n        vec4 pcbSample = texture(uPcb, pcbUV);\n        float pcbH = pcbSample.r;\n        float matID = pcbSample.g;\n\n        // Central-difference normals from height map (use PCB texel size)\n        float hL = texture(uPcb, pcbUV - vec2(uPcbTexel.x, 0.0)).r;\n        float hR = texture(uPcb, pcbUV + vec2(uPcbTexel.x, 0.0)).r;\n        float hD = texture(uPcb, pcbUV - vec2(0.0, uPcbTexel.y)).r;\n        float hU = texture(uPcb, pcbUV + vec2(0.0, uPcbTexel.y)).r;\n        vec3 N = normalize(vec3((hL - hR) * uNormalScale, 1.0, (hD - hU) * uNormalScale));\n\n        // --- Shadow (area light: 5 perpendicular samples for distinct penumbra) ---\n        vec2 ld2 = normalize(vec2(0.4, 0.35) / uPcbTexel) * uPcbTexel;\n        vec2 perpDir = vec2(-ld2.y, ld2.x);  // perpendicular to light on screen\n        float lightW = 5.0;  // area light half-width in texels\n        vec2 pStep = perpDir * lightW;\n        float shadow = 0.0;\n        shadow += shadowRay(pcbUV - pStep, pcbH, -1.0);\n        shadow += shadowRay(pcbUV - pStep * 0.5, pcbH, -1.0);\n        shadow += shadowRay(pcbUV, pcbH, -1.0);\n        shadow += shadowRay(pcbUV + pStep * 0.5, pcbH, -1.0);\n        shadow += shadowRay(pcbUV + pStep, pcbH, -1.0);\n        shadow *= 0.2;\n\n        // Contact shadow for recessed features (dimples, white keys)\n        // Sample toward light; if terrain is higher, pit wall blocks light\n        if (pcbH < -0.002) {\n            vec2 ld = normalize(vec2(0.4, 0.35) / uPcbTexel) * uPcbTexel;\n            float maxOccl = 0.0;\n            for (int i = 1; i <= 6; i++) {\n                float sH = texture(uPcb, pcbUV + ld * float(i)).r;\n                float occl = sH - pcbH; // positive = terrain above us\n                maxOccl = max(maxOccl, occl);\n            }\n            shadow *= 1.0 - clamp(maxOccl * 40.0, 0.0, 0.85);\n        }\n\n        // Paint drop shadow: ray march that skips own dome (matID=4) to avoid\n        // self-shadow striping, plus analytical curvature for smooth edge darkening\n        if (matID > 3.5 && matID < 4.5) {\n            // Full area-light shadow but filtered to ignore dome's own surface\n            float dropShadow = 0.0;\n            dropShadow += shadowRay(pcbUV - pStep, pcbH, 4.0);\n            dropShadow += shadowRay(pcbUV - pStep * 0.5, pcbH, 4.0);\n            dropShadow += shadowRay(pcbUV, pcbH, 4.0);\n            dropShadow += shadowRay(pcbUV + pStep * 0.5, pcbH, 4.0);\n            dropShadow += shadowRay(pcbUV + pStep, pcbH, 4.0);\n            dropShadow *= 0.2;\n            // Analytical curvature: subtle darkening on side away from light\n            vec2 lightDir2D = normalize(vec2(0.4, 0.35));\n            float tiltToLight = dot(N.xz, lightDir2D);\n            float domeCurve = 0.65 + 0.35 * smoothstep(-0.5, 0.0, tiltToLight);\n            shadow = dropShadow * domeCurve;\n        }\n\n        // --- Material coloring ---\n        // World UV for procedural textures\n        vec2 worldUV = fieldUV;\n        vec3 baseCol;\n        float roughness = 0.18;\n        vec3 pcbPaint = paintColor(worldUV * 3.0);\n        if (matID < 0.5) {\n            // 0: PCB base\n            baseCol = pcbPaint;\n        } else if (matID < 1.5) {\n            // 1: Convex dimples  same paint, shadow/highlight from normals\n            baseCol = pcbPaint;\n        } else if (matID < 2.5) {\n            // 2: Concave dimples  same paint, shadow from normals\n            baseCol = pcbPaint;\n        } else if (matID < 3.5) {\n            // 3: Bent pins  same paint, shape from normals\n            baseCol = pcbPaint;\n        } else if (matID < 4.5) {\n            // 4.0: Yellow paint drops, 4.1: Hot pink paint drops\n            if (matID > 4.05) {\n                // Hot pink with darker warbly edge\n                float edgeT = smoothstep(0.0, 0.024, pcbH); // 0 at rim, 1 at center (full dome range)\n                float wobble = (vnoise(worldUV * 200.0 + uTime * 0.3) - 0.5) * 0.15;\n                float rimDark = smoothstep(0.45 + wobble, 0.80 + wobble, edgeT);\n                // Modulate pink with paint texture variation (rust/green splotches)\n                float paintVar = length(pcbPaint) / length(vec3(0.85, 0.62, 0.05));\n                vec3 darkPink = vec3(0.35, 0.04, 0.12) * paintVar;\n                vec3 brightPink = vec3(0.95, 0.15, 0.45) * paintVar;\n                baseCol = mix(darkPink, brightPink, rimDark);\n            } else {\n                baseCol = pcbPaint * 1.1;\n            }\n            roughness = 0.12;\n        } else if (matID < 5.5) {\n            // 5: Capacitors  dark epoxy\n            baseCol = vec3(0.04, 0.03, 0.02);\n            roughness = 0.25;\n        } else if (matID < 6.5) {\n            // 6: Painted chips  yellow matching board\n            baseCol = paintColor(worldUV * 3.0) * 0.92;\n            roughness = 0.15;\n        } else {\n            // 7: Dark chips  exposed IC\n            baseCol = vec3(0.06, 0.04, 0.03);\n            roughness = 0.10;\n        }\n\n        // --- PBR Lighting ---\n        // V is computed per-pixel from perspective camera above\n        vec3 L = normalize(vec3(0.4, 1.0, 0.35)); // upper-right, mostly overhead for strong specular\n        vec3 H = normalize(L + V);\n\n        float NdotL = max(dot(N, L), 0.0);\n        float NdotV = max(dot(N, V), 0.001);\n        float NdotH = max(dot(N, H), 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        // GGX clear coat\n        float ccA2 = roughness * roughness * roughness * roughness;\n        float D = ggxD(NdotH, ccA2);\n        float G = ggxG(NdotV, NdotL, roughness);\n        float F = fresnelSchlick(VdotH, 0.04);\n        float clearCoat = D * G * F / (4.0 * NdotV * NdotL + 0.001);\n\n        // Fill light\n        vec3 L2 = normalize(vec3(-0.4, 0.6, -0.3)); // fill from lower-left\n        float NdotL2 = max(dot(N, L2), 0.0);\n\n        vec3 Lcol = vec3(1.0, 0.96, 0.90) * 2.5;\n        vec3 L2col = vec3(0.20, 0.18, 0.12);\n\n        vec3 diffuse = baseCol / PI;\n        vec3 pcbCol = diffuse * (1.0 - F) * Lcol * NdotL * shadow;\n        pcbCol += diffuse * L2col * NdotL2 * (0.15 + 0.85 * shadow);\n        pcbCol += baseCol * 0.04; // very low ambient for harsh shadows\n        pcbCol += vec3(clearCoat) * Lcol * NdotL * shadow;\n\n        // Environment reflection for metallic/glossy materials\n        float envFresnel = fresnelSchlick(NdotV, 0.04);\n        pcbCol += vec3(0.4, 0.35, 0.25) * envFresnel * 0.15 * shadow;\n\n        pcbCol *= uPcbBright;\n\n        // --- Ferrofluid compositing ---\n        float thick = texture(uThick, fieldUV).r;\n        float slimeAlpha = smoothstep(0.0, 0.005, thick);\n\n        // Poke-through: short features show through thin fluid\n        // pcbH is in world units (~0-0.065), thick is in simulation units (~0-1.0)\n        float pokeScale = 15.0; // tunable: higher = features poke through more easily\n        float pokeH = max(pcbH, 0.0) * pokeScale;\n        if (pokeH > 0.001) {\n            float pokeMask = smoothstep(0.0, pokeH, thick);\n            slimeAlpha *= pokeMask;\n        }\n\n        // Fluid surface normals from thickness gradient\n        vec2 fieldTexel = uTexel * uVisScale;\n        float tL = texture(uThick, fieldUV - vec2(fieldTexel.x, 0.0)).r;\n        float tR = texture(uThick, fieldUV + vec2(fieldTexel.x, 0.0)).r;\n        float tD = texture(uThick, fieldUV - vec2(0.0, fieldTexel.y)).r;\n        float tU = texture(uThick, fieldUV + vec2(0.0, fieldTexel.y)).r;\n        vec3 fluidN = vec3((tL - tR) * uNrmStr, 1.0, (tD - tU) * uNrmStr);\n\n        // Tilt cone peaks radially outward from swarm center\n        for (int i = 0; i < 15; i++) {\n            if (i >= uConeCount) break;\n            float sq = uConeSquash[i];\n            float baseRadius = uConeRadius;\n            vec2 cd = fieldUV - uConePos[i];\n            cd = cd - round(cd);\n            cd.y *= uAspectYX;\n            vec2 sqDirT = uConeSquashDir[i];\n            float sqDirLenT = length(sqDirT);\n            float cdist;\n            if (sq > 0.01 && sqDirLenT > 0.01) {\n                vec2 nT = sqDirT / sqDirLenT;\n                float sfT = 1.0 / max(1.0 - sq, 0.35);\n                float aNT = dot(cd, nT);\n                vec2 pNT = cd - aNT * nT;\n                cdist = sqrt(dot(pNT, pNT) / sfT + aNT * aNT * sfT);\n            } else {\n                cdist = length(cd);\n            }\n            float tiltMask = smoothstep(baseRadius * 0.5 * 1.5, 0.0, cdist);\n            if (tiltMask > 0.0) {\n                vec2 radial = uConePos[i] - (uScrollOffset + uVisScale * 0.5);\n                float rl = length(radial);\n                if (rl > 0.001) {\n                    radial /= rl;\n                    fluidN.x += radial.x * tiltMask * 0.6;\n                    fluidN.z += radial.y * tiltMask * 0.6;\n                }\n            }\n        }\n        fluidN = normalize(fluidN);\n\n        // Ferrofluid: RD coral/brain pattern + analytical pink rings\n        float rdB = texture(uRDState, fieldUV).g;\n        float rdThick = texture(uThick, fieldUV).r;\n\n        // Thickness-dependent threshold for pattern width\n        float rdLo = mix(uRDThLo, uRDThCLo, rdThick);\n        float rdHi = mix(uRDThHi, uRDThCHi, rdThick);\n        float rdPattern = smoothstep(rdLo, rdHi, rdB);\n\n        // Gamma curve\n        float rdGamma = mix(uRDGammaEdge, uRDGammaCenter, rdThick);\n        rdPattern = pow(rdPattern, rdGamma);\n\n        // Sharpening (normalized sigmoid)\n        float sharpAmt = uRDSharpen;\n        if (sharpAmt > 0.01) {\n            float k = 1.0 + sharpAmt * 30.0;\n            float s0 = 1.0 / (1.0 + exp(k * 0.5));\n            float s1 = 1.0 / (1.0 + exp(-k * 0.5));\n            rdPattern = (1.0 / (1.0 + exp(-k * (rdPattern - 0.5))) - s0) / (s1 - s0);\n        }\n\n        // Analytical pink ring from cones (height=1.5, sigma=coneRadius matching rd-scale-test2)\n        float rdConeField = 0.0;\n        for (int i = 0; i < 15; i++) {\n            if (i >= uConeCount) break;\n            float sq_r = uConeSquash[i];\n            vec2 sqDir_r = uConeSquashDir[i];\n            float sqDirLen_r = length(sqDir_r);\n            vec2 rd = fieldUV - uConePos[i];\n            rd = rd - round(rd);\n            rd.y *= uAspectYX;\n            float sigma = uConeRadius * 0.5;\n            float sigma2 = sigma * sigma;\n            float rd_dist2;\n            if (sq_r > 0.01 && sqDirLen_r > 0.01) {\n                vec2 n_r = sqDir_r / sqDirLen_r;\n                float sf_r = 1.0 / max(1.0 - sq_r, 0.35);\n                float aN_r = dot(rd, n_r);\n                vec2 pN_r = rd - aN_r * n_r;\n                rd_dist2 = dot(pN_r, pN_r) / sf_r + aN_r * aN_r * sf_r;\n            } else {\n                rd_dist2 = dot(rd, rd);\n            }\n            rdConeField += 1.5 * exp(-rd_dist2 / (2.0 * sigma2));\n        }\n        float rdThresh = uRDRingWidth * 0.1;\n        float rdHW = uRDRingThick * 0.5;\n        float ring = smoothstep(rdThresh - rdHW - rdHW * 0.3, rdThresh - rdHW, rdConeField)\n                   * (1.0 - smoothstep(rdThresh + rdHW, rdThresh + rdHW + rdHW * 0.3, rdConeField));\n        ring *= uRDRingStr;\n        rdPattern = mix(rdPattern, 1.0, ring);\n\n        // Per-cone coloring: each cone gets a unique curated color\n        // All colors in linear space  will be gamma-corrected at output\n        vec3 conePalette[5];\n        conePalette[0] = vec3(0.95, 0.12, 0.08);  // warm red-coral\n        conePalette[1] = vec3(0.90, 0.60, 0.03);  // amber-gold\n        conePalette[2] = vec3(0.06, 0.85, 0.35);  // emerald green\n        conePalette[3] = vec3(0.12, 0.40, 0.95);  // deep blue\n        conePalette[4] = vec3(0.65, 0.10, 0.88);  // violet-purple\n\n        // Slow rotation: each cone's color assignment shifts over time\n        float stepSec = 150.0;\n        float fullCycle = stepSec * 5.0;\n        float phase = mod(uTime, fullCycle);\n        float slot = phase / stepSec;\n        int rotOff = int(floor(slot));\n        float rotFrac = fract(slot);\n        rotFrac = rotFrac * rotFrac * (3.0 - 2.0 * rotFrac);\n\n        // Compute per-cone influence at this pixel (wide Gaussian)\n        float coneW[5];\n        float wTotal = 0.0;\n        for (int i = 0; i < 5; i++) {\n            if (i >= uConeCount) { coneW[i] = 0.0; continue; }\n            float sq_c = uConeSquash[i];\n            vec2 sqDir_c = uConeSquashDir[i];\n            float sqDirLen_c = length(sqDir_c);\n            vec2 cd_c = fieldUV - uConePos[i];\n            cd_c = cd_c - round(cd_c);\n            cd_c.y *= uAspectYX;\n            float sigma_c = uConeRadius * 2.0;\n            float sigma2_c = sigma_c * sigma_c;\n            float dist2_c;\n            if (sq_c > 0.01 && sqDirLen_c > 0.01) {\n                vec2 n_c = sqDir_c / sqDirLen_c;\n                float sf_c = 1.0 / max(1.0 - sq_c, 0.35);\n                float aN_c = dot(cd_c, n_c);\n                vec2 pN_c = cd_c - aN_c * n_c;\n                dist2_c = dot(pN_c, pN_c) / sf_c + aN_c * aN_c * sf_c;\n            } else {\n                dist2_c = dot(cd_c, cd_c);\n            }\n            float w = exp(-dist2_c / (2.0 * sigma2_c));\n            coneW[i] = w;\n            wTotal += w;\n        }\n\n        // Weighted blend of cone colors\n        vec3 ridgeCol = vec3(0.0);\n        if (wTotal > 0.001) {\n            for (int i = 0; i < 5; i++) {\n                if (i >= uConeCount) break;\n                int idx0 = int(mod(float(i + rotOff), 5.0));\n                int idx1 = int(mod(float(i + rotOff + 1), 5.0));\n                vec3 cCol = mix(conePalette[idx0], conePalette[idx1], rotFrac);\n                ridgeCol += cCol * coneW[i];\n            }\n            ridgeCol /= wTotal;\n        } else {\n            int idx0 = int(mod(float(rotOff), 5.0));\n            int idx1 = int(mod(float(rotOff + 1), 5.0));\n            ridgeCol = mix(conePalette[idx0], conePalette[idx1], rotFrac);\n        }\n\n        vec3 darkCol = vec3(0.0);\n        vec3 fluidBase = mix(darkCol, ridgeCol, rdPattern);\n        float heartGlow = uHeartPulse * 0.5 + 0.5;\n        fluidBase *= 1.0 + heartGlow * 0.35 * rdPattern;\n        for (int i = 0; i < 4; i++) {\n            vec3 tring = uTapRings[i];\n            if (tring.z < 0.0 || tring.z > uTapRingLife) continue;\n            float ringAge = tring.z;\n            float ringRadius = ringAge * uTapRingSpeed;\n            vec2 ringDelta = fieldUV - tring.xy;\n            ringDelta = ringDelta - round(ringDelta);\n            float ringDist = length(ringDelta);\n            float ringWidth = 0.008 + ringAge * 0.004;\n            float ringBand = exp(-pow((ringDist - ringRadius) / ringWidth, 2.0));\n            float ringFade = 1.0 - ringAge / uTapRingLife;\n            ringFade *= ringFade;\n            float ringMask = slimeAlpha;\n            fluidBase += ridgeCol * 1.5 * ringBand * ringFade * ringMask;\n        }\n\n        float fluidRough = uFluidRough;\n        float fluidF0 = uFluidF0;\n\n        // PBR lighting for fluid surface\n        float fNdotL = max(dot(fluidN, L), 0.0);\n        float fNdotV = max(dot(fluidN, V), 0.001);\n        float fNdotH = max(dot(fluidN, normalize(L + V)), 0.0);\n        float fVdotH = max(dot(V, normalize(L + V)), 0.0);\n        float fA2 = fluidRough * fluidRough * fluidRough * fluidRough;\n        float fD = ggxD(fNdotH, fA2);\n        float fG = ggxG(fNdotV, fNdotL, fluidRough);\n        float fF = fresnelSchlick(fVdotH, fluidF0);\n        float fluidSpec = fD * fG * fF / (4.0 * fNdotV * fNdotL + 0.001);\n\n        // Diffuse shading reveals cone 3D form + specular highlight on top\n        vec3 fluidCol = fluidBase * (uAmbient + (1.0 - uAmbient) * fNdotL) + vec3(fluidSpec) * Lcol * fNdotL;\n\n        // Rim light: only at steep edges where surface is nearly perpendicular to camera\n        float rim = pow(1.0 - fNdotV, uFluidRimPow);\n        fluidCol += vec3(0.35, 0.30, 0.25) * rim * uFluidRim;\n\n        vec3 col = mix(pcbCol, fluidCol, slimeAlpha);\n\n        // Cursor hover glow: subtle warmth on PCB surface near cursor\n        if (uHoverGlow > 0.001) {\n            vec2 gd = fieldUV - uHoverGround;\n            gd = gd - round(gd);\n            gd.y *= uAspectYX;\n            float gDist = length(gd);\n            float glowR = uConeRadius * 0.5 * 5.0;\n            float glow = exp(-gDist * gDist / (2.0 * glowR * glowR));\n            float glowAmt = glow * uHoverGlow * 0.12;\n            col += vec3(0.15, 0.10, 0.05) * glowAmt;\n        }\n\n        // Vignette: darken edges to draw focus to center\n        vec2 vigUV = vUV - 0.5;\n        vigUV.y *= uAspectYX;\n        float vigDist = length(vigUV);\n        col *= 1.0 - 0.65 * smoothstep(0.15, 0.55, vigDist);\n\n        // Gamma correction\n        col = pow(clamp(col, 0.0, 1.0), vec3(1.0 / 2.2));\n        fragColor = vec4(col, 1.0);\n    }",
                dispProg = linkProg(vertSrc, dispFragSrc),
                dispLocs = {
                    flow: gl.getUniformLocation(dispProg, 'uFlow'),
                    thick: gl.getUniformLocation(dispProg, 'uThick'),
                    pcb: gl.getUniformLocation(dispProg, 'uPcb'),
                    rdState: gl.getUniformLocation(dispProg, 'uRDState'),
                    scrollOffset: gl.getUniformLocation(dispProg, 'uScrollOffset'),
                    texel: gl.getUniformLocation(dispProg, 'uTexel'),
                    pcbTexel: gl.getUniformLocation(dispProg, 'uPcbTexel'),
                    coneCount: gl.getUniformLocation(dispProg, 'uConeCount'),
                    conePos: [],
                    coneRadius: gl.getUniformLocation(dispProg, 'uConeRadius'),
                    aspectYX: gl.getUniformLocation(dispProg, 'uAspectYX'),
                    fluidRim: gl.getUniformLocation(dispProg, 'uFluidRim'),
                    fluidRimPow: gl.getUniformLocation(dispProg, 'uFluidRimPow'),
                    camPitch: gl.getUniformLocation(dispProg, 'uCamPitch'),
                    nrmStr: gl.getUniformLocation(dispProg, 'uNrmStr'),
                    ambient: gl.getUniformLocation(dispProg, 'uAmbient'),
                    fluidRoughU: gl.getUniformLocation(dispProg, 'uFluidRough'),
                    fluidF0U: gl.getUniformLocation(dispProg, 'uFluidF0'),
                    time: gl.getUniformLocation(dispProg, 'uTime'),
                    shadowSteps: gl.getUniformLocation(dispProg, 'uShadowSteps'),
                    heartPulse: gl.getUniformLocation(dispProg, 'uHeartPulse'),
                    tapRings: [],
                    tapRingSpeed: gl.getUniformLocation(dispProg, 'uTapRingSpeed'),
                    tapRingLife: gl.getUniformLocation(dispProg, 'uTapRingLife'),
                    visScale: gl.getUniformLocation(dispProg, 'uVisScale'),
                    hoverGround: gl.getUniformLocation(dispProg, 'uHoverGround'),
                    hoverGlow: gl.getUniformLocation(dispProg, 'uHoverGlow'),
                    coneSquash: [],
                    coneSquashDir: [],
                };
            for (ci = 0; ci < 15; ci++)
                dispLocs.conePos.push(gl.getUniformLocation(dispProg, 'uConePos[' + ci + ']'));
            for (ci = 0; ci < 15; ci++)
                dispLocs.coneSquash.push(gl.getUniformLocation(dispProg, 'uConeSquash[' + ci + ']'));
            for (ci = 0; ci < 15; ci++)
                dispLocs.coneSquashDir.push(gl.getUniformLocation(dispProg, 'uConeSquashDir[' + ci + ']'));
            for (ci = 0; ci < 4; ci++)
                dispLocs.tapRings.push(gl.getUniformLocation(dispProg, 'uTapRings[' + ci + ']'));
            var blurFragSrc =
                    '#version 300 es\n    precision highp float;\n    in vec2 vUV;\n    uniform sampler2D uScene;\n    uniform vec2 uDir;         // (1/W, 0) or (0, 1/H)\n    uniform float uBlurInner;  // inner radius (no blur), fraction of screen width\n    uniform float uBlurOuter;  // outer radius (max blur), fraction of screen width\n    uniform float uBlurMax;    // max blur radius in pixels\n    uniform float uAspect;     // W/H for circular falloff\n    out vec4 fragColor;\n    void main() {\n        vec2 centered = vUV - 0.5;\n        centered.y /= uAspect;  // correct for aspect ratio  circular\n        float dist = length(centered);\n        float blurT = smoothstep(uBlurInner, uBlurOuter, dist);\n        float radius = blurT * uBlurMax;\n        if (radius < 0.5) {\n            fragColor = texture(uScene, vUV);\n            return;\n        }\n        float sigma = radius / 3.0;\n        float invSig2 = 1.0 / (2.0 * sigma * sigma);\n        vec4 sum = vec4(0.0);\n        float wSum = 0.0;\n        int N = min(int(ceil(radius)), 15);\n        for (int i = -15; i <= 15; i++) {\n            if (i < -N || i > N) continue;\n            float fi = float(i);\n            float w = exp(-fi * fi * invSig2);\n            sum += texture(uScene, vUV + uDir * fi) * w;\n            wSum += w;\n        }\n        fragColor = sum / wSum;\n    }',
                blurProg = linkProg(vertSrc, blurFragSrc),
                blurLocs = {
                    scene: gl.getUniformLocation(blurProg, 'uScene'),
                    dir: gl.getUniformLocation(blurProg, 'uDir'),
                    blurInner: gl.getUniformLocation(blurProg, 'uBlurInner'),
                    blurOuter: gl.getUniformLocation(blurProg, 'uBlurOuter'),
                    blurMax: gl.getUniformLocation(blurProg, 'uBlurMax'),
                    aspect: gl.getUniformLocation(blurProg, 'uAspect'),
                };
            function createScreenFBO() {
                var e = gl.createTexture();
                (gl.bindTexture(gl.TEXTURE_2D, e),
                    gl.texImage2D(
                        gl.TEXTURE_2D,
                        0,
                        gl.RGBA8,
                        W,
                        H,
                        0,
                        gl.RGBA,
                        gl.UNSIGNED_BYTE,
                        null,
                    ),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE),
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));
                var n = gl.createFramebuffer();
                return (
                    gl.bindFramebuffer(gl.FRAMEBUFFER, n),
                    gl.framebufferTexture2D(
                        gl.FRAMEBUFFER,
                        gl.COLOR_ATTACHMENT0,
                        gl.TEXTURE_2D,
                        e,
                        0,
                    ),
                    { fbo: n, tex: e }
                );
            }
            var sceneFBO = createScreenFBO(),
                blurFBO = createScreenFBO(),
                frameNum = 0,
                lastTime = performance.now(),
                smoothDt = 1 / 60,
                elapsedTime = 0,
                fpsAccum = 0,
                fpsFrames = 0,
                fpsDisplay = 0,
                frameMsAccum = 0,
                timingFrames = 0,
                frameMsDisplay = 0,
                gpuFenceBuf = new Uint8Array(4),
                qualityScale = 1,
                targetFps = 60,
                startupPhase = !0;
            function render(e) {
                var n = Math.min((e - lastTime) / 1e3, 0.1);
                lastTime = e;
                var o = frameNum < 3 ? n : 0.8 * smoothDt + 0.2 * n;
                ((smoothDt = o), (elapsedTime += o), frameNum++);
                // --- Smooth zoom interpolation ---
                if (Math.abs(viewZoom - viewZoomTarget) > 0.001) {
                    var zoomLerp = 1 - Math.pow(0.001, o);
                    viewZoom += (viewZoomTarget - viewZoom) * zoomLerp;
                } else {
                    viewZoom = viewZoomTarget;
                }
                // --- Heartbeat pulse update ---
                var coneMaxSpeed = 0;
                for (var hi = 0; hi < Math.min(5, coneSeeds.length); hi++) {
                    var hspd = Math.sqrt(coneSeeds[hi].vx * coneSeeds[hi].vx + coneSeeds[hi].vy * coneSeeds[hi].vy);
                    if (hspd > coneMaxSpeed) coneMaxSpeed = hspd;
                }
                var exciteInput = Math.min(coneMaxSpeed / (maxSpeed * 0.1), 1);
                heartExcitement += (exciteInput - heartExcitement) * Math.min(3 * o, 1);
                heartExcitement = Math.max(heartExcitement, 0);
                heartRate = 0.8 + 2.2 * heartExcitement;
                heartAmplitude = 0.03 + 0.07 * heartExcitement;
                heartPhase += heartRate * o;
                heartPulse = Math.sin(heartPhase * 2 * Math.PI);
                heartPulsePositive = Math.max(0, heartPulse);
                // Age tap rings, remove expired
                for (var tri = tapRings.length - 1; tri >= 0; tri--) {
                    tapRings[tri].age += o;
                    if (tapRings[tri].age > TAP_RING_LIFETIME) tapRings.splice(tri, 1);
                }
                // --- Hover cursor tracking ---
                hoverFieldX = screenToWorldX(hoverX);
                hoverFieldY = screenToWorldY(hoverY);
                var hoverDx = hoverX - prevHoverX;
                var hoverDy = hoverY - prevHoverY;
                var hoverSpeed = Math.sqrt(hoverDx * hoverDx + hoverDy * hoverDy) / Math.max(o, 0.001);
                hoverVelX += (hoverDx / Math.max(o, 0.001) - hoverVelX) * Math.min(8 * o, 1);
                hoverVelY += (hoverDy / Math.max(o, 0.001) - hoverVelY) * Math.min(8 * o, 1);
                prevHoverX = hoverX;
                prevHoverY = hoverY;
                var hoverStr = hoverActive ? 0.15 + Math.min(hoverSpeed * 0.3, 0.6) : 0;
                var t = Math.min(Math.round(5), coneSeeds.length);
                if (mouseDown) {
                    // Compute mouse movement this frame
                    var mouseDx = mouseX - prevMouseX,
                        mouseDy = mouseY - prevMouseY,
                        mouseSpeed = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy) / Math.max(o, 0.001);

                    // Virtual joystick displacement (existing behavior)
                    var a = mouseX - mouseDownX,
                        r = mouseY - mouseDownY,
                        l = Math.sqrt(a * a + r * r);

                    // Determine if mouse is "still": small joystick displacement AND low mouse velocity
                    var isStill = l < 0.03 && mouseSpeed < 0.5;

                    if (isStill) {
                        vortexTime += o;
                    } else {
                        vortexTime = Math.max(0, vortexTime - o * 3);
                    }

                    if (vortexTime > VORTEX_RAMP_TIME) {
                        // --- VORTEX MODE ---
                        vortexCenterX = screenToWorldX(mouseX);
                        vortexCenterY = screenToWorldY(mouseY);

                        var vRamp = Math.min((vortexTime - VORTEX_RAMP_TIME) / VORTEX_RAMP_TIME, 1);
                        var vRampSmooth = vRamp * vRamp * (3 - 2 * vRamp);

                        vortexOmega = VORTEX_MAX_OMEGA * vRampSmooth;

                        // Radius contracts slowly (6x ramp time = 1.8s to reach min)
                        var radiusRamp = Math.min((vortexTime - VORTEX_RAMP_TIME) / (VORTEX_RAMP_TIME * 6), 1);
                        var radiusRampSmooth = radiusRamp * radiusRamp * (3 - 2 * radiusRamp);
                        var vRadius = VORTEX_MAX_RADIUS - (VORTEX_MAX_RADIUS - VORTEX_MIN_RADIUS) * radiusRampSmooth;

                        vortexAngle += vortexOmega * o;

                        var coneCount = Math.min(Math.round(5), coneSeeds.length);
                        for (var vi = 0; vi < coneCount; vi++) {
                            var coneAngle = vortexAngle + (2 * Math.PI * vi) / coneCount;
                            var tx = vortexCenterX + vRadius * Math.cos(coneAngle);
                            var ty = vortexCenterY + vRadius * Math.sin(coneAngle);
                            if (chladniTargets[vi]) {
                                var blendRate = Math.min(8 * o * (0.3 + 0.7 * vRampSmooth), 1);
                                chladniTargets[vi].ux += (tx - chladniTargets[vi].ux) * blendRate;
                                chladniTargets[vi].uy += (ty - chladniTargets[vi].uy) * blendRate;
                            }
                            if (chladniTargetFrom[vi]) {
                                chladniTargetFrom[vi].ux = chladniTargets[vi].ux;
                                chladniTargetFrom[vi].uy = chladniTargets[vi].uy;
                            }
                            if (chladniTargetTo[vi]) {
                                chladniTargetTo[vi].ux = chladniTargets[vi].ux;
                                chladniTargetTo[vi].uy = chladniTargets[vi].uy;
                            }
                        }
                    } else if (l > 0.001) {
                        var i = l * 1.5 * maxSpeed * getVisScale() / 0.5;
                        shiftAllTargets(a / l * i * o, r / l * i * o);
                    }
                } else {
                    if (flingTimer > 0) {
                        flingTimer -= o;
                    }
                    if (explosionTimer > 0) {
                        explosionTimer -= o;
                    }
                    vortexTime = Math.max(0, vortexTime - o * 5);
                    vortexOmega = 0;
                }
                prevMouseX = mouseX;
                prevMouseY = mouseY;
                var s = 0.075 * ((arrowKeys.right ? 1 : 0) - (arrowKeys.left ? 1 : 0)) * o,
                    f = 0.075 * ((arrowKeys.up ? 1 : 0) - (arrowKeys.down ? 1 : 0)) * o,
                    d = mouseDown || 0 !== s || 0 !== f;
                if (wasMovingInput && !d) {
                    if (fissionMode === 'split') {
                        fissionMode = 'merging';
                        fissionMergeT = 0;
                    }
                    if (vortexTime > VORTEX_RAMP_TIME) {
                        // EXPLOSION: apply radial outward velocity boost to each cone
                        flingTimer = VORTEX_FLING_DURATION;
                        explosionTimer = EXPLOSION_FLOW_DURATION;
                        explosionCenterX = vortexCenterX;
                        explosionCenterY = vortexCenterY;
                        // Spawn visual shockwave ring at vortex center
                        tapRings.push({ fx: vortexCenterX, fy: vortexCenterY, age: 0 });
                        if (tapRings.length > TAP_RING_MAX) tapRings.shift();
                        var coneCount = Math.min(Math.round(5), coneSeeds.length);
                        for (var fi = 0; fi < coneCount; fi++) {
                            var cone = coneSeeds[fi];
                            var rx = cone.px - vortexCenterX;
                            var ry = cone.py - vortexCenterY;
                            var rLen = Math.sqrt(rx * rx + ry * ry);
                            if (rLen > 0.0001) {
                                // Radial outward direction
                                var radX = rx / rLen;
                                var radY = ry / rLen;
                                // Tangential direction (for visual spin)
                                var sign = vortexOmega >= 0 ? 1 : -1;
                                var tangX = -ry / rLen * sign;
                                var tangY = rx / rLen * sign;
                                // Mix: 75% radial outward, 25% tangential
                                var explodeX = radX * 0.75 + tangX * 0.25;
                                var explodeY = radY * 0.75 + tangY * 0.25;
                                // Normalize the mixed direction
                                var elen = Math.sqrt(explodeX * explodeX + explodeY * explodeY);
                                if (elen > 0.0001) { explodeX /= elen; explodeY /= elen; }
                                // Speed based on omega and stronger boost
                                var flingSpeed = Math.abs(vortexOmega) * Math.max(rLen, VORTEX_MIN_RADIUS) * VORTEX_FLING_BOOST;
                                flingSpeed = Math.min(flingSpeed, 0.5 * maxSpeed);
                                cone.vx += explodeX * flingSpeed;
                                cone.vy += explodeY * flingSpeed;
                            }
                        }
                        // Set targets to current cone positions (don't fight the fling)
                        for (var fi = 0; fi < coneCount; fi++) {
                            var cone = coneSeeds[fi];
                            if (chladniTargets[fi]) {
                                chladniTargets[fi].ux = cone.px;
                                chladniTargets[fi].uy = cone.py;
                            }
                            if (chladniTargetFrom[fi]) {
                                chladniTargetFrom[fi].ux = cone.px;
                                chladniTargetFrom[fi].uy = cone.py;
                            }
                            if (chladniTargetTo[fi]) {
                                chladniTargetTo[fi].ux = cone.px;
                                chladniTargetTo[fi].uy = cone.py;
                            }
                        }
                        chladniTargetT = 1;
                        vortexTime = 0;
                        vortexOmega = 0;
                    } else {
                        // Normal release: existing snap-to-median code
                        var u = [],
                            g = [];
                        for (c = 0; c < t; c++) (u.push(coneSeeds[c].px), g.push(coneSeeds[c].py));
                        (u.sort(function (e, n) {
                            return e - n;
                        }),
                            g.sort(function (e, n) {
                                return e - n;
                            }));
                        var p = Math.floor(t / 2),
                            h = u[p],
                            m = g[p];
                        for (l = 0, i = 0, c = 0; c < t; c++)
                            (x = chladniTargets[c]) && ((l += x.ux), (i += x.uy));
                        for (shiftAllTargets(h - (l /= t), m - (i /= t)), c = 0; c < t; c++)
                            (x = chladniTargets[c]) &&
                                ((chladniTargetFrom[c] = { ux: x.ux, uy: x.uy }),
                                (chladniTargetTo[c] = { ux: x.ux, uy: x.uy }));
                        chladniTargetT = 1;
                    }
                }
                if (!mouseDown && (0 !== s || 0 !== f))
                    if (wasMovingInput) shiftAllTargets(s, f);
                    else {
                        var v = scrollX + 0.25,
                            T = scrollY + 0.25;
                        for (
                            v += 0.125 * ((arrowKeys.right ? 1 : 0) - (arrowKeys.left ? 1 : 0)),
                                T += 0.125 * ((arrowKeys.up ? 1 : 0) - (arrowKeys.down ? 1 : 0)),
                                l = 0,
                                i = 0,
                                c = 0;
                            c < t;
                            c++
                        ) {
                            var x;
                            (x = chladniTargets[c]) && ((l += x.ux), (i += x.uy));
                        }
                        shiftAllTargets(v - (l /= t), T - (i /= t));
                    }
                wasMovingInput = d;

                // --- Fission state machine update ---
                var _fDragMag = mouseDown ? Math.sqrt((mouseX - mouseDownX) * (mouseX - mouseDownX) + (mouseY - mouseDownY) * (mouseY - mouseDownY)) * 1.5 * maxSpeed : 0;
                var _fIsFastDrag = mouseDown && _fDragMag > FISSION_SPEED_THRESH * maxSpeed && flingTimer <= 0 && vortexTime <= VORTEX_RAMP_TIME;

                if (_fIsFastDrag) {
                    fissionBuildup = Math.min(fissionBuildup + FISSION_BUILDUP_RATE * o, FISSION_TRIGGER * 1.5);
                } else {
                    fissionBuildup = Math.max(0, fissionBuildup - FISSION_DECAY_RATE * o);
                }

                // Trigger split
                if (fissionMode === 'unified' && fissionBuildup >= FISSION_TRIGGER) {
                    fissionMode = 'split';
                    fissionTimer = 0;
                    // Assign groups: 2 farthest cones from cursor become prey
                    var _fCursorWX = screenToWorldX(mouseX);
                    var _fCursorWY = screenToWorldY(mouseY);
                    var _fConeDists = [];
                    var _fConeCount = Math.min(5, coneSeeds.length);
                    for (var _fi = 0; _fi < _fConeCount; _fi++) {
                        var _fdx = coneSeeds[_fi].px - _fCursorWX;
                        var _fdy = coneSeeds[_fi].py - _fCursorWY;
                        _fConeDists.push({ idx: _fi, dist: Math.sqrt(_fdx * _fdx + _fdy * _fdy) });
                    }
                    _fConeDists.sort(function(a, b) { return b.dist - a.dist; });
                    for (var _fi = 0; _fi < 15; _fi++) coneGroup[_fi] = 0;
                    coneGroup[_fConeDists[0].idx] = 1;
                    coneGroup[_fConeDists[1].idx] = 1;
                }

                // Update split behavior
                if (fissionMode === 'split') {
                    fissionTimer += o;
                    preyJitterPhase += preyJitterFreq * o;

                    var _fCursorWX2 = screenToWorldX(mouseX);
                    var _fCursorWY2 = screenToWorldY(mouseY);
                    var _fConeCount2 = Math.min(5, coneSeeds.length);

                    // Compute group centroids
                    var _fPredCX = 0, _fPredCY = 0, _fPredN = 0;
                    var _fPreyCX = 0, _fPreyCY = 0, _fPreyN = 0;
                    for (var _fi = 0; _fi < _fConeCount2; _fi++) {
                        if (coneGroup[_fi] === 0) {
                            _fPredCX += coneSeeds[_fi].px; _fPredCY += coneSeeds[_fi].py; _fPredN++;
                        } else {
                            _fPreyCX += coneSeeds[_fi].px; _fPreyCY += coneSeeds[_fi].py; _fPreyN++;
                        }
                    }
                    if (_fPredN > 0) { _fPredCX /= _fPredN; _fPredCY /= _fPredN; }
                    if (_fPreyN > 0) { _fPreyCX /= _fPreyN; _fPreyCY /= _fPreyN; }

                    // Override chladni targets for each group
                    for (var _fi = 0; _fi < _fConeCount2; _fi++) {
                        if (coneGroup[_fi] === 0) {
                            // PREDATOR: target = cursor position with small formation offset
                            var _fPredAngle = (2 * Math.PI * _fi) / Math.max(_fPredN, 1);
                            var _fPredFormR = 0.02;
                            var _fTx = _fCursorWX2 + _fPredFormR * Math.cos(_fPredAngle);
                            var _fTy = _fCursorWY2 + _fPredFormR * Math.sin(_fPredAngle);
                            if (chladniTargets[_fi]) {
                                var _fBlend = Math.min(PREDATOR_SPRING_MULT * 4 * o, 1);
                                chladniTargets[_fi].ux += (_fTx - chladniTargets[_fi].ux) * _fBlend;
                                chladniTargets[_fi].uy += (_fTy - chladniTargets[_fi].uy) * _fBlend;
                            }
                        } else {
                            // PREY: flee opposite cursor direction with jitter
                            var _fFleeDx = _fPreyCX - _fCursorWX2;
                            var _fFleeDy = _fPreyCY - _fCursorWY2;
                            var _fFleeDist = Math.sqrt(_fFleeDx * _fFleeDx + _fFleeDy * _fFleeDy);
                            if (_fFleeDist < 0.001) { _fFleeDx = 1; _fFleeDy = 0; _fFleeDist = 1; }
                            var _fEscX = _fCursorWX2 + (_fFleeDx / _fFleeDist) * PREY_ESCAPE_RADIUS;
                            var _fEscY = _fCursorWY2 + (_fFleeDy / _fFleeDist) * PREY_ESCAPE_RADIUS;
                            // Add jitter
                            var _fPerpX = -_fFleeDy / _fFleeDist;
                            var _fPerpY = _fFleeDx / _fFleeDist;
                            var _fJit1 = 0.02 * Math.sin(preyJitterPhase + _fi * 2.5);
                            var _fJit2 = 0.01 * Math.cos(preyJitterPhase * 1.7 + _fi * 4.1);
                            _fEscX += _fPerpX * _fJit1 + (_fFleeDx / _fFleeDist) * _fJit2;
                            _fEscY += _fPerpY * _fJit1 + (_fFleeDy / _fFleeDist) * _fJit2;
                            if (chladniTargets[_fi]) {
                                var _fBlend2 = Math.min(6 * o, 1);
                                chladniTargets[_fi].ux += (_fEscX - chladniTargets[_fi].ux) * _fBlend2;
                                chladniTargets[_fi].uy += (_fEscY - chladniTargets[_fi].uy) * _fBlend2;
                            }
                        }
                        // Prevent chladni interpolation from fighting
                        if (chladniTargetFrom[_fi]) {
                            chladniTargetFrom[_fi].ux = chladniTargets[_fi].ux;
                            chladniTargetFrom[_fi].uy = chladniTargets[_fi].uy;
                        }
                        if (chladniTargetTo[_fi]) {
                            chladniTargetTo[_fi].ux = chladniTargets[_fi].ux;
                            chladniTargetTo[_fi].uy = chladniTargets[_fi].uy;
                        }
                    }

                    // Start merging if time expired or drag stopped
                    if ((fissionTimer > FISSION_SPLIT_DURATION && !_fIsFastDrag) || (!mouseDown && fissionTimer > 1.0)) {
                        fissionMode = 'merging';
                        fissionMergeT = 0;
                    }
                }

                // Merge transition
                if (fissionMode === 'merging') {
                    fissionMergeT += o / FISSION_MERGE_DURATION;

                    // Blend prey targets toward predator centroid
                    var _fMConeCount = Math.min(5, coneSeeds.length);
                    var _fMPredCX = 0, _fMPredCY = 0, _fMPredN = 0;
                    for (var _fi = 0; _fi < _fMConeCount; _fi++) {
                        if (coneGroup[_fi] === 0) {
                            _fMPredCX += coneSeeds[_fi].px; _fMPredCY += coneSeeds[_fi].py; _fMPredN++;
                        }
                    }
                    if (_fMPredN > 0) { _fMPredCX /= _fMPredN; _fMPredCY /= _fMPredN; }
                    for (var _fi = 0; _fi < _fMConeCount; _fi++) {
                        if (coneGroup[_fi] === 1 && chladniTargets[_fi]) {
                            var _fMBlend = Math.min(fissionMergeT * 3 * o, 1);
                            chladniTargets[_fi].ux += (_fMPredCX - chladniTargets[_fi].ux) * _fMBlend;
                            chladniTargets[_fi].uy += (_fMPredCY - chladniTargets[_fi].uy) * _fMBlend;
                        }
                    }

                    if (fissionMergeT >= 1.0) {
                        // Merge complete
                        fissionMode = 'unified';
                        fissionBuildup = 0;
                        fissionMergeT = 0;
                        for (var _fi = 0; _fi < 15; _fi++) coneGroup[_fi] = 0;

                        // Trigger merger splash via tap ring at merge centroid
                        var _fMergeCX = 0, _fMergeCY = 0;
                        for (var _fi = 0; _fi < _fMConeCount; _fi++) {
                            _fMergeCX += coneSeeds[_fi].px; _fMergeCY += coneSeeds[_fi].py;
                        }
                        _fMergeCX /= _fMConeCount; _fMergeCY /= _fMConeCount;
                        tapRings.push({ fx: _fMergeCX, fy: _fMergeCY, age: 0 });
                        if (tapRings.length > TAP_RING_MAX) tapRings.shift();

                        // Radial impulse outward from merge point
                        for (var _fi = 0; _fi < _fMConeCount; _fi++) {
                            var _fMdx = coneSeeds[_fi].px - _fMergeCX;
                            var _fMdy = coneSeeds[_fi].py - _fMergeCY;
                            var _fMdist = Math.sqrt(_fMdx * _fMdx + _fMdy * _fMdy);
                            if (_fMdist > 0.001) {
                                coneSeeds[_fi].vx += (_fMdx / _fMdist) * 0.3;
                                coneSeeds[_fi].vy += (_fMdy / _fMdist) * 0.3;
                            }
                        }
                        heartExcitement = Math.min(heartExcitement + 0.4, 1);
                    }
                }
                // --- End fission state machine ---

                var b = 0,
                    D = 0;
                for (c = 0; c < t; c++) ((b += coneSeeds[c].px), (D += coneSeeds[c].py));
                ((b /= t), (D /= t));
                var _visScale = getVisScale(),
                    w = 1 - Math.pow(0.05, o),
                    R = scrollX,
                    E = scrollY,
                    S = (smoothComX += (b - smoothComX) * w) - (scrollX + _visScale * 0.5),
                    U = (smoothComY += (D - smoothComY) * w) - (scrollY + _visScale * 0.5),
                    y = Math.sqrt(S * S + U * U),
                    _deadZone = 0.03 * _visScale / 0.5;
                if (y > _deadZone) {
                    var F = y - _deadZone;
                    ((F = Math.min(F, 0.075 * maxSpeed * o * _visScale / 0.5)),
                        (scrollX += (S / y) * F),
                        (scrollY += (U / y) * F));
                }
                var A = (scrollX - R) / Math.max(o, 0.001),
                    L = (scrollY - E) / Math.max(o, 0.001);
                (buildCellData(), updateConeWander(o, Math.sqrt(A * A + L * L)));
                // Debug: log cone positions during drag (every 30 frames)
                if (mouseDown && frameNum % 30 === 0) {
                    var _dbgPos = [];
                    for (var _di = 0; _di < t; _di++) {
                        var _dc = coneSeeds[_di];
                        _dbgPos.push('c' + _di + ':(' + _dc.px.toFixed(3) + ',' + _dc.py.toFixed(3) +
                            ' v:' + Math.sqrt(_dc.vx*_dc.vx + _dc.vy*_dc.vy).toFixed(3) + ')');
                    }
                    console.log('[blob-debug] f=' + frameNum + ' ' + _dbgPos.join(' '));
                }
                var P = 0.5 * coneRad * 1,
                    C = [];
                for (c = 0; c < t; c++) {
                    var k = coneSeeds[c],
                        _ = k.vx + A,
                        M = k.vy + L;
                    C.push(k.px, k.py, _, M);
                    var X = 0.15 * k.vx,
                        V = 0.15 * k.vy,
                        I = Math.sqrt(X * X + V * V);
                    I > P && ((X = (X / I) * P), (V = (V / I) * P));
                    var G = k.px + X,
                        B = k.py + V;
                    ((k.tipX += (G - k.tipX) * Math.min(6 * o, 1)),
                        (k.tipY += (B - k.tipY) * Math.min(6 * o, 1)));
                }
                (gl.viewport(0, 0, OBS_W, OBS_H),
                    gl.useProgram(obsGenProg),
                    gl.bindFramebuffer(gl.FRAMEBUFFER, obsFBO.fbo),
                    gl.uniform2f(obsGenLocs.scrollOffset, scrollX, scrollY),
                    gl.uniform1f(obsGenLocs.aspectYX, H / W),
                    gl.activeTexture(gl.TEXTURE0),
                    gl.bindTexture(gl.TEXTURE_2D, chipDataTex),
                    gl.uniform1i(obsGenLocs.chipData, 0),
                    gl.activeTexture(gl.TEXTURE1),
                    gl.bindTexture(gl.TEXTURE_2D, coarseDataTex),
                    gl.uniform1i(obsGenLocs.coarseData, 1),
                    gl.uniform2i(
                        obsGenLocs.chipGridMin,
                        cellGridInfo.chipMinGX,
                        cellGridInfo.chipMinGY,
                    ),
                    gl.uniform2i(
                        obsGenLocs.coarseGridMin,
                        cellGridInfo.coarseMinGX,
                        cellGridInfo.coarseMinGY,
                    ),
                    gl.bindVertexArray(quadVAO),
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4),
                    gl.viewport(0, 0, PCB_W, PCB_H),
                    gl.useProgram(pcbGenProg),
                    gl.bindFramebuffer(gl.FRAMEBUFFER, pcbFBO.fbo),
                    gl.uniform2f(pcbGenLocs.scrollOffset, scrollX, scrollY),
                    gl.uniform1f(pcbGenLocs.visHalf, VIS_HALF),
                    gl.uniform1f(pcbGenLocs.fineDensity, 0.6),
                    gl.uniform1f(pcbGenLocs.aspectYX, H / W),
                    gl.uniform1f(pcbGenLocs.corridorWidth, 0.06),
                    gl.uniform1f(pcbGenLocs.mazeSpacing, 0.25),
                    gl.uniform1f(pcbGenLocs.corridorWobble, 0.03),
                    gl.activeTexture(gl.TEXTURE0),
                    gl.bindTexture(gl.TEXTURE_2D, chipDataTex),
                    gl.uniform1i(pcbGenLocs.chipData, 0),
                    gl.activeTexture(gl.TEXTURE1),
                    gl.bindTexture(gl.TEXTURE_2D, coarseDataTex),
                    gl.uniform1i(pcbGenLocs.coarseData, 1),
                    gl.uniform2i(
                        pcbGenLocs.chipGridMin,
                        cellGridInfo.chipMinGX,
                        cellGridInfo.chipMinGY,
                    ),
                    gl.uniform2i(
                        pcbGenLocs.coarseGridMin,
                        cellGridInfo.coarseMinGX,
                        cellGridInfo.coarseMinGY,
                    ),
                    gl.bindVertexArray(quadVAO),
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4),
                    gl.viewport(0, 0, W, H),
                    gl.useProgram(flowUpdateProg),
                    gl.bindFramebuffer(gl.FRAMEBUFFER, flowB.fbo),
                    gl.activeTexture(gl.TEXTURE0),
                    gl.bindTexture(gl.TEXTURE_2D, flowA.tex),
                    gl.activeTexture(gl.TEXTURE1),
                    gl.bindTexture(gl.TEXTURE_2D, obsFBO.tex),
                    gl.uniform1i(flowLocs.flow, 0),
                    gl.uniform1i(flowLocs.obs, 1),
                    gl.uniform2f(flowLocs.texel, 1 / W, 1 / H),
                    gl.uniform1f(flowLocs.diffuse, 0.01),
                    gl.uniform2f(flowLocs.scrollOffset, scrollX, scrollY),
                    gl.uniform1f(flowLocs.visHalf, VIS_HALF),
                    gl.uniform2f(flowLocs.aspect, 1, W / H),
                    gl.uniform1f(flowLocs.aspectYX, H / W),
                    gl.uniform2f(flowLocs.scrollVel, A, L),
                    gl.uniform1i(flowLocs.coneCount, t),
                    gl.uniform1f(flowLocs.coneRadius, coneRad * (1 + heartAmplitude * heartPulse)),
                    gl.uniform1f(flowLocs.maxSpeed, maxSpeed));
                // Vortex flow uniforms
                var vortexStr = vortexTime > VORTEX_RAMP_TIME ?
                    Math.min((vortexTime - VORTEX_RAMP_TIME) / VORTEX_RAMP_TIME, 1) * 0.8 : 0;
                gl.uniform2f(flowLocs.vortexPos, vortexCenterX, vortexCenterY);
                gl.uniform1f(flowLocs.vortexStr, vortexStr);
                // Explosion flow uniforms
                var explosionStr = explosionTimer > 0 ?
                    Math.pow(explosionTimer / EXPLOSION_FLOW_DURATION, 2) * 0.9 : 0;
                gl.uniform2f(flowLocs.explosionPos, explosionCenterX, explosionCenterY);
                gl.uniform1f(flowLocs.explosionStr, explosionStr);
                // Heartbeat radial flow pulse
                var heartFlowStr = heartPulsePositive * heartPulsePositive * heartAmplitude * 8.0;
                gl.uniform2f(flowLocs.heartCenter, smoothComX, smoothComY);
                gl.uniform1f(flowLocs.heartFlow, heartFlowStr);
                gl.uniform2f(flowLocs.hoverPos, hoverFieldX, hoverFieldY);
                gl.uniform1f(flowLocs.hoverStr, hoverStr);
                gl.uniform2f(flowLocs.hoverVel, hoverVelX, hoverVelY);
                var N = elapsedTime < 1 ? 4 : 4 - 3 * Math.min(elapsedTime - 1, 1);
                for (gl.uniform1f(flowLocs.splatScale, N), c = 0; c < t; c++)
                    gl.uniform4f(
                        flowLocs.cones[c],
                        C[4 * c],
                        C[4 * c + 1],
                        C[4 * c + 2],
                        C[4 * c + 3],
                    );
                for (c = 0; c < t; c++)
                    gl.uniform1f(flowLocs.coneSquash[c], coneSeeds[c].squash);
                for (c = 0; c < t; c++)
                    gl.uniform2f(flowLocs.coneSquashDir[c], coneSeeds[c].squashNX, coneSeeds[c].squashNY);
                (gl.bindVertexArray(quadVAO), gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4));
                var O = flowA;
                for (
                    flowA = flowB,
                        flowB = O,
                        gl.viewport(0, 0, W, H),
                        gl.useProgram(thickUpdateProg),
                        gl.bindFramebuffer(gl.FRAMEBUFFER, thickB.fbo),
                        gl.activeTexture(gl.TEXTURE0),
                        gl.bindTexture(gl.TEXTURE_2D, thickA.tex),
                        gl.activeTexture(gl.TEXTURE1),
                        gl.bindTexture(gl.TEXTURE_2D, flowA.tex),
                        gl.activeTexture(gl.TEXTURE2),
                        gl.bindTexture(gl.TEXTURE_2D, obsFBO.tex),
                        gl.uniform1i(thickLocs.thick, 0),
                        gl.uniform1i(thickLocs.flow, 1),
                        gl.uniform1i(thickLocs.obs, 2),
                        gl.uniform2f(thickLocs.texel, 1 / W, 1 / H),
                        gl.uniform1f(thickLocs.decay, 1),
                        gl.uniform1f(thickLocs.diffuse, 0.02),
                        gl.uniform2f(thickLocs.scrollVel, A, L),
                        gl.uniform1f(thickLocs.dt, o),
                        gl.uniform2f(thickLocs.scrollOffset, scrollX, scrollY),
                        gl.uniform1f(thickLocs.visHalf, VIS_HALF),
                        gl.uniform1i(thickLocs.coneCount, t),
                        gl.uniform1f(thickLocs.coneRadius, coneRad * (1 + heartAmplitude * heartPulse)),
                        gl.uniform1f(thickLocs.coneEmit, coneHeight * (1 + heartAmplitude * heartPulse * 0.5)),
                        gl.uniform1f(thickLocs.coneFalloff, coneFalloff),
                        gl.uniform1f(thickLocs.trailHeight, trailHeight),
                        gl.uniform1f(thickLocs.tipShape, tipShape),
                        gl.uniform1f(thickLocs.aspectYX, H / W),
                        c = 0;
                    c < t;
                    c++
                )
                    gl.uniform4f(
                        thickLocs.cones[c],
                        C[4 * c],
                        C[4 * c + 1],
                        C[4 * c + 2],
                        C[4 * c + 3],
                    );
                for (c = 0; c < t; c++)
                    gl.uniform1f(thickLocs.coneSquash[c], coneSeeds[c].squash);
                for (c = 0; c < t; c++)
                    gl.uniform2f(thickLocs.coneSquashDir[c], coneSeeds[c].squashNX, coneSeeds[c].squashNY);
                (gl.bindVertexArray(quadVAO), gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4));
                var Y = thickA;
                ((thickA = thickB), (thickB = Y));
                var z = Math.round(12 + 18 * qualityScale),
                    q = Math.min(120 * o, 1.5);
                (gl.viewport(0, 0, RD_W, RD_H),
                    gl.useProgram(rdUpdateProg),
                    gl.activeTexture(gl.TEXTURE1),
                    gl.bindTexture(gl.TEXTURE_2D, thickA.tex),
                    gl.activeTexture(gl.TEXTURE2),
                    gl.bindTexture(gl.TEXTURE_2D, flowA.tex),
                    gl.activeTexture(gl.TEXTURE3),
                    gl.bindTexture(gl.TEXTURE_2D, rdNoiseTex),
                    gl.uniform1i(rdLocs.thick, 1),
                    gl.uniform1i(rdLocs.flow, 2),
                    gl.uniform1i(rdLocs.noise, 3),
                    gl.uniform1i(rdLocs.state, 0),
                    gl.uniform2f(rdLocs.texel, 1 / RD_W, 1 / RD_H),
                    gl.uniform1f(rdLocs.F, 0.033),
                    gl.uniform1f(rdLocs.K, 0.062),
                    gl.uniform1f(rdLocs.fCenter, 0.042),
                    gl.uniform1f(rdLocs.kCenter, 0.06),
                    gl.uniform1f(rdLocs.daMin, 0.04),
                    gl.uniform1f(rdLocs.daMax, 0.3),
                    gl.uniform1f(rdLocs.dbRatio, 0.5),
                    gl.uniform1f(rdLocs.aniso, 1.5),
                    gl.uniform1f(rdLocs.gridScale, 1.8),
                    gl.uniform1f(rdLocs.scaleClamp, 1.8),
                    gl.uniform1f(rdLocs.decayWidth, 0.75),
                    gl.uniform1f(rdLocs.fNoise, 0.005),
                    gl.uniform1f(rdLocs.kNoise, 0.003),
                    gl.uniform1f(rdLocs.fkRamp, 1),
                    gl.uniform1f(rdLocs.coneDaBoost, 1),
                    gl.uniform1f(rdLocs.coneEmit, coneHeight * (1 + heartAmplitude * heartPulse * 0.5)),
                    gl.uniform1f(rdLocs.edgeCut, edgeCut));
                var j = Math.sqrt(A * A + L * L);
                (gl.uniform1f(rdLocs.swarmSpeed, j),
                    gl.uniform1f(rdLocs.seedStr, seedStr),
                    gl.uniform1f(rdLocs.seedThr, seedThr),
                    gl.uniform1f(rdLocs.seedSpd, seedSpd));
                var K = 0;
                for (c = 0; c < t; c++) {
                    ((_ = C[4 * c + 2]), (M = C[4 * c + 3]));
                    var $ = Math.sqrt(_ * _ + M * M);
                    $ > K && (K = $);
                }
                (gl.uniform1f(rdLocs.coneSpeed, K),
                    gl.uniform1f(rdLocs.seedScale, seedScale),
                    gl.uniform1f(rdLocs.advect, rdAdvect),
                    gl.uniform1f(rdLocs.advDecay, advDecay),
                    gl.uniform1f(rdLocs.time, elapsedTime),
                    gl.uniform1f(rdLocs.simSpeed, q));
                // Heartbeat RD perturbation
                var heartFKStr = heartPulsePositive * heartPulsePositive * heartAmplitude * 10.0;
                gl.uniform1f(rdLocs.heartFKPulse, heartFKStr);
                gl.uniform2f(rdLocs.heartCenterRD, smoothComX, smoothComY);
                gl.uniform1f(rdLocs.heartRadius, coneRad * 4.0);
                gl.uniform2f(rdLocs.hoverPosRD, hoverFieldX, hoverFieldY);
                gl.uniform1f(rdLocs.hoverRDStr, hoverStr);
                gl.bindVertexArray(quadVAO);
                for (var J = 0; J < z; J++) {
                    (gl.activeTexture(gl.TEXTURE0),
                        gl.bindTexture(gl.TEXTURE_2D, rdA.tex),
                        gl.bindFramebuffer(gl.FRAMEBUFFER, rdB.fbo),
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4));
                    var Q = rdA;
                    ((rdA = rdB), (rdB = Q));
                }
                for (
                    gl.bindFramebuffer(gl.FRAMEBUFFER, blurAmt > 0 ? sceneFBO.fbo : null),
                        gl.viewport(0, 0, W, H),
                        gl.useProgram(dispProg),
                        gl.activeTexture(gl.TEXTURE0),
                        gl.bindTexture(gl.TEXTURE_2D, flowA.tex),
                        gl.activeTexture(gl.TEXTURE1),
                        gl.bindTexture(gl.TEXTURE_2D, thickA.tex),
                        gl.activeTexture(gl.TEXTURE2),
                        gl.bindTexture(gl.TEXTURE_2D, pcbFBO.tex),
                        gl.activeTexture(gl.TEXTURE3),
                        gl.bindTexture(gl.TEXTURE_2D, rdA.tex),
                        gl.uniform1i(dispLocs.flow, 0),
                        gl.uniform1i(dispLocs.thick, 1),
                        gl.uniform1i(dispLocs.pcb, 2),
                        gl.uniform1i(dispLocs.rdState, 3),
                        gl.uniform2f(dispLocs.scrollOffset, scrollX, scrollY),
                        gl.uniform1f(dispLocs.visScale, getVisScale()),
                        gl.uniform2f(dispLocs.texel, 1 / W, 1 / H),
                        gl.uniform2f(dispLocs.pcbTexel, 1 / PCB_W, 1 / PCB_H),
                        gl.uniform1i(dispLocs.coneCount, t),
                        c = 0;
                    c < t;
                    c++
                )
                    gl.uniform2f(
                        dispLocs.conePos[c],
                        coneSeeds[c].tipX,
                        coneSeeds[c].tipY,
                    );
                for (c = 0; c < t; c++)
                    gl.uniform1f(dispLocs.coneSquash[c], coneSeeds[c].squash);
                for (c = 0; c < t; c++)
                    gl.uniform2f(dispLocs.coneSquashDir[c], coneSeeds[c].squashNX, coneSeeds[c].squashNY);
                (gl.uniform1f(dispLocs.coneRadius, coneRad * (1 + heartAmplitude * heartPulse)),
                    gl.uniform1f(dispLocs.aspectYX, H / W),
                    gl.uniform1f(dispLocs.fluidRim, fluidRim),
                    gl.uniform1f(dispLocs.fluidRimPow, fluidRimPow),
                    gl.uniform1f(dispLocs.camPitch, camPitch),
                    gl.uniform1f(dispLocs.nrmStr, nrmStr),
                    gl.uniform1f(dispLocs.ambient, fluidAmbient),
                    gl.uniform1f(dispLocs.fluidRoughU, fluidRough),
                    gl.uniform1f(dispLocs.fluidF0U, fluidF0),
                    gl.uniform1f(dispLocs.time, elapsedTime));
                gl.uniform2f(dispLocs.hoverGround, hoverFieldX, hoverFieldY);
                gl.uniform1f(dispLocs.hoverGlow, hoverStr);
                gl.uniform1f(dispLocs.heartPulse, heartPulse);
                gl.uniform1f(dispLocs.tapRingSpeed, TAP_RING_SPEED);
                gl.uniform1f(dispLocs.tapRingLife, TAP_RING_LIFETIME);
                for (var tri = 0; tri < 4; tri++) {
                    if (tri < tapRings.length) {
                        gl.uniform3f(dispLocs.tapRings[tri], tapRings[tri].fx, tapRings[tri].fy, tapRings[tri].age);
                    } else {
                        gl.uniform3f(dispLocs.tapRings[tri], 0, 0, -1);
                    }
                }
                var Z = Math.round(8 + 16 * qualityScale);
                (gl.uniform1i(dispLocs.shadowSteps, Z),
                    gl.bindVertexArray(quadVAO),
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4),
                    blurAmt > 0 &&
                        (gl.useProgram(blurProg),
                        gl.uniform1i(blurLocs.scene, 0),
                        gl.uniform1f(blurLocs.blurInner, blurInner + 0.35 * (1 - qualityScale)),
                        gl.uniform1f(blurLocs.blurOuter, blurOuter),
                        gl.uniform1f(blurLocs.blurMax, blurAmt),
                        gl.uniform1f(blurLocs.aspect, W / H),
                        gl.bindVertexArray(quadVAO),
                        gl.bindFramebuffer(gl.FRAMEBUFFER, blurFBO.fbo),
                        gl.activeTexture(gl.TEXTURE0),
                        gl.bindTexture(gl.TEXTURE_2D, sceneFBO.tex),
                        gl.uniform2f(blurLocs.dir, 1 / W, 0),
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4),
                        gl.bindFramebuffer(gl.FRAMEBUFFER, null),
                        gl.activeTexture(gl.TEXTURE0),
                        gl.bindTexture(gl.TEXTURE_2D, blurFBO.tex),
                        gl.uniform2f(blurLocs.dir, 0, 1 / H),
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)));
                var ee = performance.now();
                gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, gpuFenceBuf);
                var ne = performance.now() - ee;
                ((frameMsAccum += ne),
                    timingFrames++,
                    fpsFrames++,
                    (fpsAccum += o) >= 0.5 &&
                        ((fpsDisplay = Math.round(fpsFrames / fpsAccum)),
                        (frameMsDisplay = frameMsAccum / timingFrames),
                        (fpsAccum = 0),
                        (fpsFrames = 0),
                        (frameMsAccum = 0),
                        (timingFrames = 0),
                        fpsDisplay < 0.9 * targetFps
                            ? (qualityScale = Math.max(0, qualityScale - 0.15))
                            : fpsDisplay > 1.1 * targetFps &&
                              qualityScale < 1 &&
                              (qualityScale = Math.min(1, qualityScale + 0.05)),
                        (document.getElementById('fps').textContent =
                            fpsDisplay +
                            ' fps | ' +
                            frameMsDisplay.toFixed(1) +
                            'ms' +
                            (qualityScale < 0.99 ? ' | q' + Math.round(100 * qualityScale) : '') +
                            (Math.abs(viewZoom - 1) > 0.01 ? ' | ' + viewZoom.toFixed(1) + 'x' : ''))),
                    startupPhase || requestAnimationFrame(render));
            }
            !(function () {
                var e = 0,
                    n = document.getElementById('loading');
                !(function o() {
                    for (
                        var t = Math.min(100, 1500 - e),
                            a = Math.min(5, coneSeeds.length),
                            r = [],
                            l = 0;
                        l < a;
                        l++
                    ) {
                        var i = coneSeeds[l];
                        r.push(i.px, i.py, 0, 0);
                    }
                    for (
                        gl.viewport(0, 0, OBS_W, OBS_H),
                            gl.useProgram(obsGenProg),
                            gl.bindFramebuffer(gl.FRAMEBUFFER, obsFBO.fbo),
                            gl.uniform2f(obsGenLocs.scrollOffset, scrollX, scrollY),
                            gl.uniform1f(obsGenLocs.aspectYX, H / W),
                            gl.activeTexture(gl.TEXTURE0),
                            gl.bindTexture(gl.TEXTURE_2D, chipDataTex),
                            gl.uniform1i(obsGenLocs.chipData, 0),
                            gl.activeTexture(gl.TEXTURE1),
                            gl.bindTexture(gl.TEXTURE_2D, coarseDataTex),
                            gl.uniform1i(obsGenLocs.coarseData, 1),
                            gl.uniform2i(
                                obsGenLocs.chipGridMin,
                                cellGridInfo.chipMinGX,
                                cellGridInfo.chipMinGY,
                            ),
                            gl.uniform2i(
                                obsGenLocs.coarseGridMin,
                                cellGridInfo.coarseMinGX,
                                cellGridInfo.coarseMinGY,
                            ),
                            gl.bindVertexArray(quadVAO),
                            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4),
                            gl.viewport(0, 0, W, H),
                            gl.useProgram(flowUpdateProg),
                            gl.bindFramebuffer(gl.FRAMEBUFFER, flowB.fbo),
                            gl.activeTexture(gl.TEXTURE0),
                            gl.bindTexture(gl.TEXTURE_2D, flowA.tex),
                            gl.activeTexture(gl.TEXTURE1),
                            gl.bindTexture(gl.TEXTURE_2D, obsFBO.tex),
                            gl.uniform1i(flowLocs.flow, 0),
                            gl.uniform1i(flowLocs.obs, 1),
                            gl.uniform2f(flowLocs.texel, 1 / W, 1 / H),
                            gl.uniform1f(flowLocs.diffuse, 0.01),
                            gl.uniform2f(flowLocs.scrollOffset, scrollX, scrollY),
                            gl.uniform1f(flowLocs.visHalf, VIS_HALF),
                            gl.uniform2f(flowLocs.aspect, 1, W / H),
                            gl.uniform1f(flowLocs.aspectYX, H / W),
                            gl.uniform2f(flowLocs.scrollVel, 0, 0),
                            gl.uniform2f(flowLocs.vortexPos, 0.5, 0.5),
                            gl.uniform1f(flowLocs.vortexStr, 0),
                            gl.uniform2f(flowLocs.explosionPos, 0.5, 0.5),
                            gl.uniform1f(flowLocs.explosionStr, 0),
                            gl.uniform2f(flowLocs.hoverPos, 0.5, 0.5),
                            gl.uniform1f(flowLocs.hoverStr, 0),
                            gl.uniform2f(flowLocs.hoverVel, 0, 0),
                            gl.uniform1i(flowLocs.coneCount, a),
                            gl.uniform1f(flowLocs.coneRadius, coneRad),
                            gl.uniform1f(flowLocs.splatScale, 4),
                            l = 0;
                        l < a;
                        l++
                    )
                        gl.uniform4f(flowLocs.cones[l], r[4 * l], r[4 * l + 1], 0, 0);
                    for (l = 0; l < a; l++)
                        gl.uniform1f(flowLocs.coneSquash[l], 0);
                    for (l = 0; l < a; l++)
                        gl.uniform2f(flowLocs.coneSquashDir[l], 0, 0);
                    (gl.bindVertexArray(quadVAO), gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4));
                    var c = flowA;
                    for (
                        flowA = flowB,
                            flowB = c,
                            gl.viewport(0, 0, W, H),
                            gl.useProgram(thickUpdateProg),
                            gl.bindFramebuffer(gl.FRAMEBUFFER, thickB.fbo),
                            gl.activeTexture(gl.TEXTURE0),
                            gl.bindTexture(gl.TEXTURE_2D, thickA.tex),
                            gl.activeTexture(gl.TEXTURE1),
                            gl.bindTexture(gl.TEXTURE_2D, flowA.tex),
                            gl.activeTexture(gl.TEXTURE2),
                            gl.bindTexture(gl.TEXTURE_2D, obsFBO.tex),
                            gl.uniform1i(thickLocs.thick, 0),
                            gl.uniform1i(thickLocs.flow, 1),
                            gl.uniform1i(thickLocs.obs, 2),
                            gl.uniform2f(thickLocs.texel, 1 / W, 1 / H),
                            gl.uniform1f(thickLocs.decay, 1),
                            gl.uniform1f(thickLocs.diffuse, 0.02),
                            gl.uniform2f(thickLocs.scrollVel, 0, 0),
                            gl.uniform1f(thickLocs.dt, 1 / 60),
                            gl.uniform2f(thickLocs.scrollOffset, scrollX, scrollY),
                            gl.uniform1f(thickLocs.visHalf, VIS_HALF),
                            gl.uniform1i(thickLocs.coneCount, a),
                            gl.uniform1f(thickLocs.coneRadius, coneRad),
                            gl.uniform1f(thickLocs.coneEmit, coneHeight),
                            gl.uniform1f(thickLocs.coneFalloff, coneFalloff),
                            gl.uniform1f(thickLocs.trailHeight, trailHeight),
                            gl.uniform1f(thickLocs.tipShape, tipShape),
                            gl.uniform1f(thickLocs.aspectYX, H / W),
                            l = 0;
                        l < a;
                        l++
                    )
                        gl.uniform4f(thickLocs.cones[l], r[4 * l], r[4 * l + 1], 0, 0);
                    for (l = 0; l < a; l++)
                        gl.uniform1f(thickLocs.coneSquash[l], 0);
                    for (l = 0; l < a; l++)
                        gl.uniform2f(thickLocs.coneSquashDir[l], 0, 0);
                    (gl.bindVertexArray(quadVAO), gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4));
                    var s,
                        f,
                        d = thickA;
                    ((thickA = thickB),
                        (thickB = d),
                        gl.viewport(0, 0, RD_W, RD_H),
                        gl.useProgram(rdUpdateProg),
                        gl.activeTexture(gl.TEXTURE1),
                        gl.bindTexture(gl.TEXTURE_2D, thickA.tex),
                        gl.activeTexture(gl.TEXTURE2),
                        gl.bindTexture(gl.TEXTURE_2D, flowA.tex),
                        gl.activeTexture(gl.TEXTURE3),
                        gl.bindTexture(gl.TEXTURE_2D, rdNoiseTex),
                        gl.uniform1i(rdLocs.thick, 1),
                        gl.uniform1i(rdLocs.flow, 2),
                        gl.uniform1i(rdLocs.noise, 3),
                        gl.uniform1i(rdLocs.state, 0),
                        gl.uniform2f(rdLocs.texel, 1 / RD_W, 1 / RD_H),
                        gl.uniform1f(rdLocs.F, 0.033),
                        gl.uniform1f(rdLocs.K, 0.062),
                        gl.uniform1f(rdLocs.fCenter, 0.042),
                        gl.uniform1f(rdLocs.kCenter, 0.06),
                        gl.uniform1f(rdLocs.daMin, 0.04),
                        gl.uniform1f(rdLocs.daMax, 0.3),
                        gl.uniform1f(rdLocs.dbRatio, 0.5),
                        gl.uniform1f(rdLocs.aniso, 1.5),
                        gl.uniform1f(rdLocs.gridScale, 1.8),
                        gl.uniform1f(rdLocs.scaleClamp, 1.8),
                        gl.uniform1f(rdLocs.decayWidth, 0.75),
                        gl.uniform1f(rdLocs.fNoise, 0.005),
                        gl.uniform1f(rdLocs.kNoise, 0.003),
                        gl.uniform1f(rdLocs.fkRamp, 1),
                        gl.uniform1f(rdLocs.coneDaBoost, 1),
                        gl.uniform1f(rdLocs.coneEmit, coneHeight),
                        gl.uniform1f(rdLocs.edgeCut, edgeCut),
                        gl.uniform1f(rdLocs.swarmSpeed, 0),
                        gl.uniform1f(rdLocs.seedStr, seedStr),
                        gl.uniform1f(rdLocs.seedThr, seedThr),
                        gl.uniform1f(rdLocs.seedSpd, seedSpd),
                        gl.uniform1f(rdLocs.coneSpeed, 0),
                        gl.uniform1f(rdLocs.seedScale, seedScale),
                        gl.uniform1f(rdLocs.advect, rdAdvect),
                        gl.uniform1f(rdLocs.advDecay, advDecay),
                        gl.uniform1f(rdLocs.time, 0),
                        gl.uniform1f(rdLocs.simSpeed, 1),
                        gl.uniform2f(rdLocs.hoverPosRD, 0.5, 0.5),
                        gl.uniform1f(rdLocs.hoverRDStr, 0),
                        gl.bindVertexArray(quadVAO));
                    for (var u = 0; u < t; u++) {
                        (gl.activeTexture(gl.TEXTURE0),
                            gl.bindTexture(gl.TEXTURE_2D, rdA.tex),
                            gl.bindFramebuffer(gl.FRAMEBUFFER, rdB.fbo),
                            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4));
                        var g = rdA;
                        ((rdA = rdB), (rdB = g));
                    }
                    (gl.flush(),
                        (e += t) < 1500
                            ? setTimeout(o, 0)
                            : ((s = 0),
                              (f = []),
                              requestAnimationFrame(function e() {
                                  var o = performance.now();
                                  (render(performance.now()),
                                      gl.readPixels(
                                          0,
                                          0,
                                          1,
                                          1,
                                          gl.RGBA,
                                          gl.UNSIGNED_BYTE,
                                          gpuFenceBuf,
                                      ));
                                  var t = performance.now() - o;
                                  if ((++s > 2 && f.push(t), s < 10)) requestAnimationFrame(e);
                                  else {
                                      f.sort(function (e, n) {
                                          return e - n;
                                      });
                                      var a = f[Math.floor(f.length / 2)],
                                          r = 1e3 / targetFps;
                                      ((qualityScale =
                                          a > 1.5 * r ? 0 : a > 1.2 * r ? 0.3 : a > r ? 0.6 : 1),
                                          (n.style.opacity = '0'),
                                          setTimeout(function () {
                                              n.style.display = 'none';
                                          }, 400),
                                          (startupPhase = !1),
                                          (lastTime = performance.now()),
                                          (smoothDt = 1 / 60),
                                          (frameNum = 0),
                                          requestAnimationFrame(render));
                                  }
                              })));
                })();
            })();
        </script>
    </body>
</html>
